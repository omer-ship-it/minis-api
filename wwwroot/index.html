<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>MiniMenu</title>

    <!-- iOS PWA niceties (optional) -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Theme & PWA -->
    <meta name="theme-color" content="#111111" />
    <link rel="manifest" href="manifest.webmanifest" />
    <link rel="icon" href="icons/icon-192.png" sizes="192x192" />

    <!-- 3rd party libs -->
    <script src="https://js.stripe.com/v3"></script>
    <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDvdt_-e6V-ijiqwU9osiCzwNc2b9S1QAA&libraries=maps,places"></script>
    <script async src="https://unpkg.com/@googlemaps/extended-component-library@0.6/dist/loader.js"></script>

    <!-- App styles -->
    <style>
        #stickyBarHost {
            position: fixed;
            top: env(safe-area-inset-top, 0);
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 430px;
            z-index: 1200; /* below sheets (2xxx), above content */
            background: var(--bg);
        }

            #stickyBarHost .pillbar {
                display: flex;
                gap: .5rem;
                padding: .75rem 1rem;
                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
                white-space: nowrap;
                scrollbar-width: none;
            }

                #stickyBarHost .pillbar::-webkit-scrollbar {
                    display: none;
                }



        /* push content down so it doesn't hide under the fixed bar */
        .app-col {
            padding-top: calc(var(--catbar-h, 56px) + env(safe-area-inset-top, 0));

        }

        /* jump targets won’t hide under the fixed bar */
        .section {
            scroll-margin-top: calc(var(--catbar-h, 56px) + 12px);
        }

        .pillbar {
            padding: .75rem 12px; /* a bit more side padding helps first/last */
            overscroll-behavior-x: contain; /* prevent bounce fighting the tween */
        }

        :root {
            --brand: #111;
            --bg: #f7f5f1;
            --pill: #fff;
        }

        html, body {
            height: 100%;
        }

            body.stage {
                margin: 0;
                background: #ffffff;
                color: #111;
                font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
                display: flex;
                justify-content: center;
                align-items: stretch;
                overflow-x: hidden;
            }

        .app-col {
            width: 100%;
            max-width: 430px;
            height: 100svh;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #app {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            box-sizing: border-box;
            padding-bottom:80px;
        }

        /* Sticky categories bar (only horizontal scroller, scrollbar hidden) */

        .pill {
            display: inline-flex;
            align-items: center;
            border-radius: 999px;
            border: 1px solid #0000001a;
            padding: .6rem 1rem;
            background: var(--pill);
            font-weight: 800;
            font-size: .8rem;
            letter-spacing: .4px;
            white-space: nowrap;
            flex: 0 0 auto;
            cursor: pointer;
            color: #777; /* default gray */
        }

            .pill.selected {
                color: #000; /* selected = black */
            }

        @media (max-width: 520px) {
            .pill {
                font-size: 1rem; /* bigger text */
                padding: 0.8rem 1.1rem; /* more touch-friendly hit area */
            }
        }

        .title {
            margin: 30px 1rem 10px;
            font-size: 2rem;
            font-weight: 400;
            font-family: Georgia, "Times New Roman", serif;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0,1fr));
            gap: 1rem;
            padding: 1rem;
            box-sizing: border-box;
            max-width: 100%;
        }

        @media (min-width:480px) {
            .grid {
                grid-template-columns: repeat(auto-fit, minmax(160px,1fr));
            }
        }

        @media (max-width:520px) {
            .app-col {
                max-width: none;
                height: 100svh;
            }
        }

        .card {
            background: #fff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0,0,0,.06);
            cursor: pointer;
        }

            .card img {
                display: block;
                width: 100%;
                height: 140px;
                object-fit: cover;
                background: #eee;
            }

        .card-body {
            padding: .6rem .8rem .9rem;
            box-sizing: border-box;
        }

        .name {
            font-weight: 800;
            text-transform: uppercase;
            min-height: 2.2em;
        }

        .price {
            color: #213C34;
            font-weight: 700;
            margin-top: .25rem;
        }

        /* —— Product Sheet (bottom modal) —— */
        .sheet-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.4);
            display: none;
            z-index: 2000; /* higher than basket */
        }

        .sheet {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: -100%;
            width: 100%;
            max-width: 430px;
            background: var(--bg);
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
            box-shadow: 0 -10px 40px rgba(0,0,0,.35);
            display: grid;
            grid-template-rows: auto 1fr auto;
            max-height: 90svh;
            overflow: hidden;
            z-index: 2001; /* above backdrop + basket */
            transition: bottom .25s ease;
        }

            .sheet.open {
                bottom: 0;
            }

        .sheet-header {
            position: relative;
            height: 300px;
            overflow: hidden;
            background: #ddd;
        }

            .sheet-header img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                display: block;
            }


        /* Shared close button style */
        .sheet-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #f0f0f0; /* light gray background */
            color: #000; /* black X */
            border: none;
            border-radius: 50%; /* round */
            width: 36px;
            height: 36px;
            font-size: 22px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }

            .sheet-close:hover {
                background: #e0e0e0; /* slightly darker hover */
            }



        .sheet-title {
            font-weight: 800;
            font-size: 20px;
            margin: 8px 0 6px;
        }

        .sheet-desc {
            color: #333;
            font-size: 14px;
            line-height: 1.4;
        }

        .opt-section {
            margin-top: 16px;
        }

        .opt-title {
            font-weight: 700;
            margin-bottom: 8px;
        }

        .opt-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: #fff;
            border: 1px solid #0000001a;
            border-radius: 8px;
        }

            .opt-card + .opt-card {
                margin-top: 8px;
            }

        .opt-price {
            margin-left: auto;
            color: #666;
            font-size: 13px;
        }

        .sheet-footer {
            position: sticky;
            bottom: 0;
            background: var(--bg);
            padding: 12px 16px 16px;
        }

        .qty {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-right: 12px;
            https: //circuspizza.co.uk/index.html
        }

            .qty button {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                border: none;
                background: #fff;
                font-weight: 800;
                cursor: pointer;
                box-shadow: 0 1px 3px rgba(0,0,0,.08);
            }

        .add-btn {
            display: inline-flex;
            align-items: center;
            justify-content: space-between;
            gap: 14px;
            width: 100%;
            border: none;
            cursor: pointer;
            padding: 14px 16px;
            border-radius: 10px;
            background: var(--brand);
            color: #fff;
            font-weight: 800;
            font-size: 1.0rem;
        }


        /* —— Basket Bar (fixed, centered to 430px column) —— */
        .basket-fixed {
            position: fixed;
            left: 50%;
            transform: translateX(-50%) translateY(16px);
            bottom: 10px;
            width: 100%;
            max-width: 430px;
            /* 👇 horizontal padding inside the fixed column */
            padding: 0 16px;
            box-sizing: border-box;
            z-index: 1200;
            opacity: 0;
            pointer-events: none;
            transition: opacity .3s ease, transform .3s ease;
        }

            .basket-fixed.show {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
                pointer-events: auto;
            }

        .basket-btn {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--brand);
            color: #fff;
            border: none;
            border-radius: 14px;
            padding: 12px 14px;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 6px 18px rgba(0,0,0,.18);
            font-size: 1.0rem;
        }

        .basket-qty {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #fff;
            color: var(--brand);
            display: grid;
            place-items: center;
            font-weight: 800;
            font-size: .85rem;
        }

        .basket-spacer {
            flex: 1;
        }

        /* —— Basket Sheet (bottom modal) —— */
        .basket-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.38);
            display: none;
            z-index: 2100; /* above basket bar & product sheet */
        }

        .basket-sheet {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: -100%;
            width: 100%;
            max-width: 430px;
            background: var(--bg);
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
            box-shadow: 0 -10px 40px rgba(0,0,0,.35);
            display: grid;
            grid-template-rows: auto 1fr auto;
            max-height: 90svh;
            overflow: hidden;
            z-index: 2101;
            transition: bottom .25s ease;
            font-size: 1.0rem;
        }

            .basket-sheet.open {
                bottom: 0;
            }

        .basket-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 16px;
            font-weight: 800;
            font-size: 18px;
            font-size: 1.2rem;
        }

        .basket-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #f0f0f0; /* light gray background */
            color: #000; /* black X */
            border: none; /* no border */
            border-radius: 50%; /* circular button */
            width: 36px; /* make it larger */
            height: 36px;
            font-size: 22px; /* big X */
            line-height: 1; /* avoid vertical offset */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }

            .basket-close:hover {
                background: #e0e0e0; /* slightly darker on hover */
            }

        .basket-content {
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            padding: 8px 12px 12px;
        }

        .basket-row {
            display: flex;
            gap: 10px;
            align-items: center;
            background: #fff;
            border: 1px solid #00000012;
            border-radius: 12px;
            padding: 10px;
            margin: 8px 0;
        }

        .basket-thumb {
            width: 52px;
            height: 52px;
            border-radius: 8px;
            object-fit: cover;
            background: #eee;
        }

        .basket-main {
            flex: 1;
            min-width: 0;
        }

        .basket-name {
            font-weight: 800;
            font-size: 14px;
            text-transform: uppercase;
        }

        .basket-mods {
            color: #666;
            font-size: 12px;
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .basket-line {
            font-weight: 700;
            font-size: 1.0rem;
        }

        .basket-ctrls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .basket-ctrls button {
                width: 28px;
                height: 28px;
                border-radius: 50%;
                border: none;
                background: #fff;
                cursor: pointer;
                box-shadow: 0 1px 3px rgba(0,0,0,.08);
                font-weight: 800;
            }

        .basket-trash {
            color: #b00020;
        }

        .basket-footer {
            border-top: 1px solid #00000010;
            background: var(--bg);
            padding: 14px 16px;
            font-size: 1.0rem;
        }

        .basket-tot {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
            font-weight: 400;
            font-size: 1.0rem;
        }

            .basket-tot.total {
                font-weight: 700; /* 👈 bold only for the Total row */
                font-size: 18px; /* keep your larger size if desired */
                font-size: 1.0rem;
            }

        .basket-pay {
            margin-top: 10px;
            width: 100%;
            border: none;
            border-radius: 10px;
            padding: 14px 16px;
            background: var(--brand);
            color: #fff;
            font-weight: 800;
            font-size: 1.0rem;
        }


        /* —— Basket “When / Address” cards —— */
        .info-cards {
            padding: 6px 12px 2px;
        }

        .info-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px;
            margin: 8px 0;
            background: #fff;
            border: 1px solid #00000012;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,.05);
            cursor: pointer;
        }

        .info-icon {
            font-size: 18px;
        }

        .info-main {
            flex: 1;
            min-width: 0;
        }

        .info-title {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: .2px;
            font-size: 1rem;
        }

        .info-sub {
            font-size: 14px;
            color: #222;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 1rem;
        }

        .info-chevron {
            opacity: .6;
        }

        /* —— Tiny modal (reusable) —— */
        mini-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.38);
            display: none;
            z-index: 2300;
        }

        .mini-modal {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: -100%;
            width: 100%;
            max-width: 430px;
            background: #fff;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
            box-shadow: 0 -10px 40px rgba(0,0,0,.35);
            z-index: 2301;
            transition: bottom .22s ease;
        }

            .mini-modal.open {
                bottom: 0;
            }

        .mini-body {
            padding: 16px;
        }

        .mini-title {
            font-weight: 800;
            font-size: 20px;
            margin-bottom: 12px;
        }

        .mini-row {
            margin: 12px 0;
        }

        .schedule-option {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            padding: 14px;
            border: 1px solid #00000026;
            border-radius: 12px;
            background: #fff;
            box-shadow: 0 1px 2px rgba(0,0,0,.04);
        }

            .schedule-option + .schedule-option {
                margin-top: 10px;
            }

        .pickers {
            display: flex;
            gap: 12px;
            margin-top: 12px;
        }

        .picker {
            flex: 1;
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 10px;
            padding: 8px;
        }

            .picker select {
                width: 100%;
                height: 150px;
                border: none;
                outline: none;
                font-size: 16px;
                background: #fff;
                overflow: auto;
            }

        .mini-actions {
            display: flex;
            gap: 10px;
            padding: 12px 16px 16px;
            border-top: 1px solid #00000010;
            background: #fff;
        }

            .mini-actions button {
                flex: 1;
                border: none;
                border-radius: 10px;
                padding: 12px 14px;
                font-weight: 800;
                font-size: 1.0rem;
            }

        .mini-cancel {
            background: #eee;
            color: black;
        }

        .mini-save {
            background: var(--brand);
            color: #fff;
        }

        .mini-actions {
            display: flex;
            gap: 10px;
            padding: 12px 16px 16px;
            border-top: 1px solid #00000010;
            background: #fff;
        }

            .mini-actions button {
                flex: 1;
                border: none;
                border-radius: 10px;
                padding: 12px 14px;
                font-weight: 800;
            }

        .mini-cancel {
            background: #eee;
        }

        .mini-save {
            background: var(--brand);
            color: #fff;
        }

        /* —— Full-screen Address Sheet —— */
        .addr-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.38);
            display: none;
            z-index: 2400;
        }

        .addr-sheet {
            position: fixed;
            left: 50%;
            transform: translateX(-50%) translateY(110vh);
            bottom: 0;
            top: 0;
            width: 100%;
            max-width: 430px;
            background: var(--bg);
            z-index: 2401;
            transition: transform .25s ease;
            display: grid;
            grid-template-rows: auto 1fr auto;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
        }

        #cardModal {
            z-index: 2502; /* higher than .addr-sheet (2401) and confirm view (2500) */
        }

        #cardBackdrop {
            z-index: 2501; /* backdrop just below modal */
        }


        .addr-sheet.open {
            transform: translateX(-50%) translateY(0);
        }

        /* Mobile full-bleed */
        @media (max-width: 520px) {
            .addr-sheet {
                left: 0;
                right: 0;
                max-width: none;
                width: 100vw;
                transform: translateY(100vh); /* ✅ remove translateX(-50%) */
                border-radius: 0; /* optional: full-bleed edge-to-edge */
            }

                .addr-sheet.open {
                    transform: translateY(0);
                }
        }

        .addr-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 12px;
            background: var(--bg);
            border-bottom: 1px solid #00000010;
        }

        .addr-back {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 1px 4px rgba(0,0,0,.12);
            font-weight: 800;
            cursor: pointer;
        }

        .addr-title {
            font-weight: 800;
            font-size: 17px;
        }

        .addr-content {
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            padding: 18px 14px 90px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .label {
            font-weight: 700;
            font-size: 13px;
            margin-bottom: 6px;
        }

        .input, .textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background: #fff;
            font-size: 15px;
            box-sizing: border-box;
        }

        .textarea {
            min-height: 78px;
            resize: vertical;
        }

        /* two-column row for street/number */
        .row-2 {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 10px;
        }

        /* footer */
        .addr-footer {
            border-top: 1px solid #00000010;
            background: var(--bg);
            padding: 12px 16px 16px;
        }

        .addr-save {
            width: 100%;
            border: none;
            border-radius: 12px;
            padding: 14px 16px;
            font-weight: 800;
            background: var(--brand);
            color: #fff;
            cursor: pointer;
            font-size: 1.0rem;
        }

        /* shake on error */
        .shake {
            animation: shake .35s ease-in-out;
        }

        @keyframes shake {
            0% {
                transform: translateX(0)
            }

            25% {
                transform: translateX(-8px)
            }

            50% {
                transform: translateX(8px)
            }

            75% {
                transform: translateX(-6px)
            }

            100% {
                transform: translateX(0)
            }
        }

        .error {
            border-color: #d32f2f !important;
        }

        .hint {
            color: #666;
            font-size: 12px;
            margin-top: 6px;
        }

        /* Google-style predictions dropdown */
        .ac-wrap {
            position: relative;
        }

        .ac-menu {
            position: absolute;
            left: 0;
            right: 0;
            top: 100%;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            margin-top: 6px;
            max-height: 240px;
            overflow: auto;
            z-index: 99999;
            box-shadow: 0 6px 20px rgba(0,0,0,.12);
        }

        .ac-item {
            padding: 10px 12px;
            cursor: pointer;
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }

            .ac-item:hover {
                background: #f5f5f5;
            }

        .ac-icon {
            font-size: 14px;
            opacity: .7;
            margin-top: 2px;
        }

        .ac-main {
            display: flex;
            flex-direction: column;
        }

        .ac-primary {
            font-size: 14px;
        }

        .ac-secondary {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }

        #af_postcode {
            text-transform: uppercase; /* visual uppercase */
            autocomplete: off; /* prevent browser autofill */
        }

        /* —— Confirmation view (iOS-style push) —— */
        .confirm-view {
            position: fixed;
            left: 50%;
            transform: translateX(-50%) translateX(100%); /* start off-screen to right */
            top: 0;
            bottom: 0;
            width: 100%;
            max-width: 430px;
            background: var(--bg);
            z-index: 2500;
            transition: transform .28s cubic-bezier(0.25, 0.9, 0.4, 1);
            display: grid;
            grid-template-rows: auto 1fr;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
        }

            .confirm-view.open {
                transform: translateX(-50%) translateX(0);
            }

        .confirm-nav {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 12px;
            background: var(--bg);
            border-bottom: 1px solid #00000012;
        }

        .confirm-back {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: #fff;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0,0,0,.12);
        }

        .confirm-title {
            font-weight: 800;
            font-size: 17px;
        }

        .confirm-body {
            overflow: auto;
            padding: 16px;
        }

        /* iOS-style push of the main phone view */
        .app-col {
            transition: transform .28s cubic-bezier(0.25, 0.9, 0.4, 1);
            will-change: transform;
        }

            .app-col.push-left {
                transform: translateX(-16%); /* subtle parallax; tweak 12–22% if you want */
            }

        /* Mobile: confirmation view should be full-screen, no gutters */
        @media (max-width: 520px) {
            .confirm-view {
                left: 0; /* stop centering */
                right: 0;
                width: 100vw; /* full viewport width */
                max-width: none; /* remove 430px cap */
                border-top-left-radius: 0;
                border-top-right-radius: 0;
                transform: translateX(100%); /* start off-screen to right */
            }

                .confirm-view.open {
                    transform: translateX(0); /* slide in fully */
                }

            /* Optional: don’t parallax the main view on phones */
            .app-col.push-left {
                transform: none;
            }
        }

        .app-col {
            transition: transform .28s cubic-bezier(0.25, 0.9, 0.4, 1);
            will-change: transform;
        }

            .app-col.push-left {
                transform: translateX(-16%); /* subtle parallax on large screens */
            }

        /* confirmation view base (unchanged) */
        .confirm-view {
            position: fixed;
            left: 50%;
            transform: translateX(-50%) translateX(100%); /* start off to right */
            top: 0;
            bottom: 0;
            width: 100%;
            max-width: 430px;
            background: var(--bg);
            z-index: 2500;
            transition: transform .28s cubic-bezier(0.25, 0.9, 0.4, 1);
            display: grid;
            grid-template-rows: auto 1fr;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
        }

            .confirm-view.open {
                transform: translateX(-50%) translateX(0);
            }

        /* ===== Mobile: full-screen push, same speed for both views ===== */
        @media (max-width: 520px) {
            /* confirmation view goes edge-to-edge and slides from +100vw to 0 */
            .confirm-view {
                left: 0;
                right: 0;
                width: 100vw;
                max-width: none;
                border-top-left-radius: 0;
                border-top-right-radius: 0;
                transform: translateX(100vw);
            }

                .confirm-view.open {
                    transform: translateX(0);
                }

            /* main view slides out left the same distance & timing */
            .app-col.push-left {
                transform: translateX(-100vw); /* same speed/duration as confirm-view */
            }

            /* prevent any accidental horizontal scroll during the push */
            html, body {
                overflow-x: hidden;
                font-size: 1rem;
            }
        }

        /* ===== Confirmation content ===== */
        .confirm-sections {
            padding: 16px 0 24px;
        }

        .conf-card {
            margin: 12px 16px;
            padding: 14px 16px;
            background: #f2f2f7; /* iOS gray6-ish */
            border-radius: 14px;
        }

        .conf-title {
            font-weight: 800;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .conf-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0;
            font-size: 16px;
        }

            .conf-row .right {
                margin-left: auto;
            }

        .conf-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            background: #f2f2f7;
            font-size: 14px;
        }

        .conf-eta {
            padding: 16px;
            margin: 16px;
            border-radius: 14px;
            background: #f2f2f7;
        }

        #confirmMap {
            height: 240px;
            margin: 0 16px 12px;
            border-radius: 14px;
            overflow: hidden;
            background: #eaeaea;
        }

        .conf-disclosure > summary {
            cursor: pointer;
            list-style: none;
            font-weight: 800;
            font-size: 16px;
        }

            .conf-disclosure > summary::marker {
                display: none;
            }


        /* Confirmation view cards + ETA header → white background */
        #confirmView .conf-card,
        #confirmView .conf-eta {
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08); /* optional for lift */
            padding: 16px; /* if not already set */
        }


        html, body {
            height: 100%;
        }

            /* outer page */
            body.stage {
                min-height: 100svh; /* modern small viewport */
                min-height: 100dvh; /* modern dynamic viewport (Chrome/Android) */
                background: #fff;
                overscroll-behavior-y: none; /* less bounce */
            }

        /* centered app column (phone frame) */
        .app-col {
            width: 100%;
            max-width: 430px;
            height: var(--app-h, 100dvh); /* ✅ uses visual viewport height */
            min-height: 100svh; /* fallback */
            background: var(--bg);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        /* any full-screen sheets/views should also pin to the visual viewport */
        .sheet,
        .addr-sheet,
        .confirm-view {
            max-width: 430px;
            height: var(--app-h, 100dvh);
        }

        /* mobile full-bleed variant */
        @media (max-width: 520px) {
            .confirm-view,
            .addr-sheet {
                left: 0;
                right: 0;
                max-width: none;
                height: var(--app-h, 100dvh);
            }
        }

        @media (max-width: 520px) {
            html, body {
                height: auto;
                min-height: 100svh; /* allow address bar to shrink */
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .app-col {
                height: auto; /* don't pin to vh */
                min-height: 100svh;
            }

            /* body scrolls; make inner main not capture scroll */
            #app {
                overflow: visible; /* was overflow-y:auto */
            }



            /* so headings don’t hide behind the sticky bar */
            .section {
                scroll-margin-top: calc(var(--pillbar-h, 56px) + 12px);
            }
        }



        /* Push the page down by the fixed bar height */
        .app-col {
            padding-top: calc(var(--catbar-h, 56px) + env(safe-area-inset-top, 0px));
        }

        /* When you jump to sections, don't hide titles under the fixed bar */
        .section {
            scroll-margin-top: calc(var(--catbar-h, 56px) + 12px);
        }

        input,
        textarea,
        select {
            font-size: 16px !important; /* prevent Safari auto-zoom */
        }

        /* Product sheet should hug content (not full height) */
        #productSheet.sheet {
            display: flex; /* override the grid on .sheet */
            flex-direction: column;
            height: auto; /* let content decide */
            max-height: 90svh; /* cap, so it never grows too tall */
            overflow: hidden;
        }

        /* Scroll only if content exceeds available space */
        #productSheet .sheet-content {
            flex: 0 1 auto; /* don't force-fill */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 14px 16px calc(var(--ps-footer-h, 72px) + env(safe-area-inset-bottom, 0px));
            /* ^ replaces the old padding: 14px 16px 100px; */
        }

        /* Footer stays docked; no extra layout space needed */
        #productSheet .sheet-footer {
            position: sticky;
            bottom: 0;
            flex-shrink: 0;
        }

        /* Optional: keep the header fixed height */
        #productSheet .sheet-header {
            flex-shrink: 0;
        }

        section {
            scroll-margin-top: -0px !important;
        }
    </style>
</head>

<body class="stage">
    <div id="stickyBarHost"></div>
    <div class="app-col">

        <main id="app"><p style="padding:1rem"></p></main>
    </div>

    <!-- Basket fixed bar -->
    <div id="basketFixed" class="basket-fixed">
        <button id="basketBtn" class="basket-btn" type="button">
            <span class="basket-qty" id="basketQty">0</span>
            <span>VIEW ORDER</span>
            <span class="basket-spacer"></span>
            <span id="basketTotal">£0.00</span>
        </button>
    </div>

    <!-- Product Sheet -->
    <div id="sheetBackdrop" class="sheet-backdrop"></div>
    <div id="productSheet" class="sheet" aria-hidden="true">
        <div class="sheet-header">
            <img id="sheetImg" src="" alt="">
            <button class="sheet-close" id="sheetClose" aria-label="Close">×</button>
        </div>
        <div class="sheet-content">
            <div class="sheet-title" id="sheetName"></div>
            <div class="sheet-desc" id="sheetDesc"></div>

            <div id="optionsBlock" style="display:none">
                <div class="opt-section">
                    <div class="opt-title">Choose one</div>
                    <div id="optionsList"></div>
                </div>
            </div>

            <div id="additionsBlock" style="display:none">
                <div class="opt-section">
                    <div class="opt-title">Add extras</div>
                    <div id="additionsList"></div>
                </div>
            </div>
        </div>
        <div class="sheet-footer">
            <div style="display:flex; align-items:center; gap:12px;">
                <div class="qty">
                    <button id="qtyMinus" aria-label="Decrease">−</button>
                    <span id="qtyValue" style="min-width:24px; text-align:center; font-weight:800;">1</span>
                    <button id="qtyPlus" aria-label="Increase">+</button>
                </div>
                <button class="add-btn" id="addToOrderBtn" type="button">
                    <span>ADD TO ORDER</span>
                    <span id="addPrice">£0.00</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Basket Sheet -->
    <div id="basketBackdropSheet" class="basket-backdrop"></div>
    <div id="basketSheet" class="basket-sheet" aria-hidden="true">
        <div class="basket-header">
            <span>YOUR ORDER</span>
            <button id="basketClose" class="basket-close" aria-label="Close">×</button>
        </div>

        <!-- scrollable area -->
        <div class="basket-body">
            <div id="basketContent" class="basket-content"></div>

            <div class="info-cards">
                <div id="whenCard" class="info-card">
                    <div class="info-icon">📅</div>
                    <div class="info-main">
                        <div class="info-title">WHEN</div>
                        <div id="whenValue" class="info-sub">ASAP</div>
                    </div>
                    <div class="info-chevron">›</div>
                </div>

                <div id="addressCard" class="info-card">
                    <div class="info-icon">📍</div>
                    <div class="info-main">
                        <div class="info-title">DELIVER TO</div>
                        <div id="addressValue" class="info-sub">Add delivery address</div>
                    </div>
                    <div class="info-chevron">›</div>
                </div>

                <div id="payCard" class="info-card">
                    <div class="info-icon">💳</div>
                    <div class="info-main">
                        <div class="info-title">PAY WITH</div>
                        <div id="payMethodLabel" class="info-sub">Card</div>
                    </div>
                    <div class="info-chevron">›</div>
                </div>
            </div>
        </div>

        <div class="basket-footer">
            <div class="basket-tot">
                <span>Subtotal</span><span id="bsSubtotal">£0.00</span>
            </div>
            <div class="basket-tot total" style="font-size:18px;">
                <span>Total</span><span id="bsTotal">£0.00</span>
            </div>
            <button id="bsCheckout" class="basket-pay" type="button">PAY NOW</button>
        </div>
    </div>

    <!-- WHEN modal -->
    <div id="whenBackdrop" class="mini-backdrop"></div>
    <div id="whenModal" class="mini-modal" aria-hidden="true">
        <div class="mini-body">
            <div class="mini-title">WHEN</div>

            <label class="schedule-option">
                <input type="radio" name="whenMode" value="asap" id="whenAsap" />
                <div>
                    <div style="font-weight:700;">AS SOON AS POSSIBLE</div>
                    <div id="asapHint" style="color:#222; font-size:14px;">Usually within 40–50 min</div>
                </div>
            </label>

            <label class="schedule-option">
                <input type="radio" name="whenMode" value="later" id="whenLater" />
                <div style="width:100%">
                    <div style="font-weight:700;">SCHEDULE FOR LATER</div>
                    <div id="whenSummary" style="color:#222; font-size:14px;">Pick a time</div>

                    <div class="pickers" id="pickerRow">
                        <div class="picker"><select id="daySelect" size="7"></select></div>
                        <div class="picker"><select id="timeSelect" size="7"></select></div>
                    </div>
                </div>
            </label>
        </div>
        <div class="mini-actions">
            <button class="mini-cancel" id="whenCancel">Cancel</button>
            <button class="mini-save" id="whenSave">Save</button>
        </div>
    </div>

    <!-- ADDRESS modal (simple) -->
    <div id="addrBackdrop" class="mini-backdrop"></div>
    <div id="addrModal" class="mini-modal" aria-hidden="true">
        <div class="mini-body">
            <div class="mini-title">Delivery address</div>
            <div class="mini-row">
                <textarea id="addrInput" rows="3" placeholder="Street & number, postcode"
                          style="width:100%;padding:10px;border:1px solid #ddd;border-radius:8px;resize:vertical;"></textarea>
            </div>
        </div>
        <div class="mini-actions">
            <button class="mini-cancel" id="addrCancel">Cancel</button>
            <button class="mini-save" id="addrSave">Save</button>
        </div>
    </div>

    <!-- Address Full-screen Sheet -->
    <div id="addrFsBackdrop" class="addr-backdrop"></div>
    <div id="addrFsSheet" class="addr-sheet" aria-hidden="true">
        <div class="addr-header">
            <button id="addrFsBack" class="addr-back" aria-label="Back">‹</button>
            <div class="addr-title">DELIVERY ADDRESS</div>
        </div>

        <div class="addr-content" id="addrFormWrapper">
            <div class="form-group">
                <div class="label">Postcode</div>
                <div class="ac-wrap">
                    <input id="af_postcode" class="input" placeholder="e.g. E1 6AN"
                           autocomplete="chrome-off" autocorrect="off" spellcheck="false"
                           autocapitalize="characters" data-lpignore="true"
                           onfocus="this.setAttribute('autocomplete','chrome-off')" />
                    <div id="acMenu" class="ac-menu" style="display:none;"></div>
                </div>
            </div>

            <div class="row-2">
                <div class="form-group">
                    <div class="label">Street name</div>
                    <input id="af_street" class="input" placeholder="Brick Lane" />
                </div>
                <div class="form-group">
                    <div class="label">House / flat</div>
                    <input id="af_number" class="input" placeholder="42A" />
                </div>
            </div>

            <div class="form-group">
                <div class="label">Instructions for courier (optional)</div>
                <textarea id="af_instr" class="textarea" placeholder="Gate code, buzzer, leave at door…"></textarea>
            </div>

            <div class="form-group">
                <div class="label">Name</div>
                <input id="af_name" class="input" placeholder="Your name" />
            </div>

            <div class="form-group">
                <div class="label">Phone</div>
                <input id="af_phone" class="input" placeholder="Your phone number" />
                <div id="af_phone_hint" class="hint">Will send as +44…</div>
            </div>

            <div class="form-group">
                <div class="label">Email</div>
                <input id="af_email" class="input" type="email" placeholder="you@example.com" />
            </div>
        </div>

        <div class="addr-footer">
            <button id="addrFsSave" class="addr-save" type="button">SAVE ADDRESS</button>
        </div>
    </div>

    <!-- CARD sheet -->
    <div id="cardBackdrop" class="mini-backdrop"></div>
    <div id="cardModal" class="mini-modal" aria-hidden="true">
        <div class="mini-body">
            <div class="mini-title">Pay with card</div>
            <div id="cardMount" class="stripe-card"
                 style="padding:12px;border:1px solid #ddd;border-radius:10px;background:#fff;"></div>
            <div id="cardErrors" class="hint" style="color:#b00020;margin-top:8px;"></div>
        </div>
        <div class="mini-actions">
            <button class="mini-cancel" id="cardCancel">Cancel</button>
            <button class="mini-save" id="cardSaveBtn">Save card</button>
        </div>
    </div>

    <!-- Confirmation (push) view -->
    <div id="confirmView" class="confirm-view" aria-hidden="true" style="display:none;">
        <div class="confirm-nav">
            <button id="confirmBack" class="confirm-back" aria-label="Back">‹</button>
            <div class="confirm-title">ORDER CONFIRMATION</div>
        </div>
        <div class="confirm-body" id="confirmBody">
            <p style="color:#444">This is your confirmation screen.</p>
        </div>
    </div>

    <!-- App logic -->
    <script >
        const path = window.location.pathname;  // e.g. "/shop/2"
        const parts = path.split("/").filter(Boolean);
        const SUBMIT_ORDER_URL = "/submitOrder"; // change if needed


        let miniId = null;
        if (parts[0] === "shop" && parts.length > 1) {
            miniId = parts[1];
        }

        if (miniId) {
            console.log("Mini ID:", miniId);
            // e.g. load the JSON: /json/shop{miniId}.json
            fetch(`/json/shop${miniId}.json`)
                .then(r => r.json())
                .then(data => {
                    console.log("Loaded menu for shop", miniId, data);
                    // render here
                })
                .catch(err => console.error("Failed to load menu:", err));
        } else {
            console.log("No miniId in URL → show default landing page");
        }
        // Set --app-h to the visual viewport height for better URL-bar behavior
        (function () {
            const setH = () => {
                const h = window.visualViewport ? window.visualViewport.height : window.innerHeight;
                document.documentElement.style.setProperty('--app-h', `${h}px`);
            };
            setH();
            window.addEventListener('resize', setH);
            window.visualViewport && window.visualViewport.addEventListener('resize', setH);
        })();
        // --- URL setup (proxy-first; adds cache-buster) ---
        const params = new URLSearchParams(location.search);
        const shop = params.get("shop") || 4; // default shop
        const proxyURL = `/api/menu?shop=${miniId}&t=${Date.now()}`;
        const directURL = `/json/shop${miniId}.json?${Date.now()}`;
        let confirmMap = null, confirmMapMarker = null, confirmMapShop = null, confirmMapDest = null; let confirmMapDriver = null;

        // GBP formatter
        const fmt = new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' });

        // helpers
        const el = (tag, cls, content) => { const e = document.createElement(tag); if (cls) e.className = cls; if (content !== undefined) { (typeof content === 'string') ? e.textContent = content : e.append(content); } return e; };
        const idFor = cat => 'cat-' + encodeURIComponent(String(cat).trim().replace(/\s+/g, '-'));
        const withTimeout = (p, ms, label) => Promise.race([p, new Promise((_, rej) => setTimeout(() => rej(new Error(`${label} timed out after ${ms}ms`)), ms))]);

        // ===== Basket State =====
        // structure: [{ key, id, name, unitPrice, qty, option, additions[], image }]
        let basket = loadBasket();

        function basketKey(item) {
            const opt = item.option ? item.option.name : '';
            const adds = (item.additions || []).map(a => a.name).sort().join('|');
            return `${item.id}__${opt}__${adds}`;
        }
        function addToBasket(item, qty = 1) {
            const key = basketKey(item);
            const ex = basket.find(x => x.key === key);
            if (ex) ex.qty += qty;
            else basket.push({ key, id: item.id, name: item.name, unitPrice: item.unitPrice, qty, option: item.option || null, additions: item.additions || [], image: item.image || '' });
            saveBasket(); updateBasketBar();
        }
        function basketTotals() {
            const quantity = basket.reduce((s, x) => s + x.qty, 0);
            const total = basket.reduce((s, x) => s + x.qty * x.unitPrice, 0);
            return { quantity, total };
        }
        function saveBasket() { try { localStorage.setItem('basket', JSON.stringify(basket)); } catch { } }
        function loadBasket() {
            try { const raw = localStorage.getItem('basket'); if (!raw) return []; const arr = JSON.parse(raw); return Array.isArray(arr) ? arr : []; } catch { return []; }
        }
        function updateBasketBar() {
            const { quantity, total } = basketTotals();
            const qtyEl = document.getElementById('basketQty');
            const totalEl = document.getElementById('basketTotal');

            if (quantity > 0) {
                if (qtyEl) qtyEl.textContent = String(quantity);
                if (totalEl) totalEl.textContent = fmt.format(total);
                showBasketBar();
            } else {
                hideBasketBar();
            }
        }

        // ===== Data =====
        async function loadJson() {
            try {
                const r = await withTimeout(fetch(proxyURL, { cache: 'no-store' }), 10000, '/api/menu');
                if (!r.ok) throw new Error(`API HTTP ${r.status}`);
                return await r.json();
            } catch (e) {
                console.warn('Proxy failed, trying direct:', e);
                const r2 = await withTimeout(fetch(directURL, { cache: 'no-store', mode: 'cors' }), 8000, 'direct');
                if (!r2.ok) throw new Error(`DIRECT HTTP ${r2.status}`);
                return await r2.json();
            }
        }

        async function boot() {
            updateBasketBar(); // show if persisted items exist

            const app = document.getElementById('app');
            try {
                const raw = await loadJson();

                // Theme
                const brand = raw.canvasTexts?.brandColor || raw.canvasTexts?.buttonColor || '#111111';
                document.documentElement.style.setProperty('--brand', brand);

                // Normalize products
                const products = (raw.products ?? []).map((p, i) => ({
                    id: p.id ?? p.ProductId ?? i + 1,
                    name: p.name ?? p.Name ?? 'Item',
                    price: Number(p.price ?? p.Price ?? 0),
                    category: p.category ?? p.Category ?? 'Menu',
                    image: p.imageName ?? p.Image ?? '',
                    sort: (Number.isFinite(p.sort)) ? p.sort :
                        (Number.isFinite(p.Sort)) ? p.Sort : 9999,
                    Options: p.Options, modifiers: p.modifiers,
                    Description: p.Description, description: p.description
                }));

                // Preserve category order as appears in JSON
                const categoryOrder = [];
                for (const p of products) if (!categoryOrder.includes(p.category)) categoryOrder.push(p.category);

                // Sort only inside categories
                products.sort((a, b) => {
                    if (a.category === b.category) return (a.sort - b.sort) || a.name.localeCompare(b.name);
                    return categoryOrder.indexOf(a.category) - categoryOrder.indexOf(b.category);
                });

                renderAll(products);
            } catch (err) {
                console.error(err);
                app.innerHTML = `<p style="padding:1rem;color:#b00020">Failed to load menu: ${String(err).replace(/</g, '&lt;')}</p>`;
            }
        }

        function renderAll(products) {
            const col = document.querySelector('.app-col');
            const app = document.getElementById('app');
            const host = document.getElementById('stickyBarHost'); // fixed host
            app.innerHTML = '';

            // Build pillbar
            const bar = el('div', 'pillbar');
            const cats = [...new Set(products.map(p => p.category))];
            cats.forEach(cat => {
                const btn = el('button', 'pill', cat.toUpperCase());
                btn.onclick = () => { scrollToSection(cat); centerPill(btn); setActivePill(btn); };
                bar.append(btn);
            });

            // Mount pillbar into the fixed host (replace any previous)
            if (host) {
                host.innerHTML = '';
                host.appendChild(bar);
            } else {
                // fallback (shouldn’t happen if you added the host)
                col.insertBefore(bar, app);
            }

            // Sections into #app
            cats.forEach(cat => {
                const sec = el('section', 'section'); sec.id = idFor(cat);
                sec.append(el('h2', 'title', cat));
                const grid = el('div', 'grid');
                products.filter(p => p.category === cat).forEach(p => {
                    const card = el('div', 'card');
                    const img = new Image(); img.src = p.image; img.alt = p.name; img.loading = 'lazy';
                    card.append(img);

                    const body = el('div', 'card-body');
                    body.append(el('div', 'name', p.name));
                    body.append(el('div', 'price', fmt.format(p.price)));
                    card.append(body);

                    card.onclick = () => openProductSheet(p);
                    grid.append(card);
                });
                sec.append(grid);
                app.append(sec);
            });

            // Tell CSS how tall the fixed bar is (so padding/scroll-margin work)
            const setCatbarH = () => {
                const h = (host?.offsetHeight || bar.offsetHeight || 56);
                document.documentElement.style.setProperty('--catbar-h', h + 'px');
            };
            requestAnimationFrame(setCatbarH);
            window.addEventListener('resize', setCatbarH, { passive: true });
        }
        let _pillTween = null;

        function centerPill(btn) {
            const bar = btn.parentElement;                  // .pillbar
            if (!bar) return;

            // where we want the left edge to be for perfect centering
            const target = btn.offsetLeft + (btn.offsetWidth / 2) - (bar.clientWidth / 2);

            // clamp between 0 and max scrollable
            const max = Math.max(0, bar.scrollWidth - bar.clientWidth);
            const dst = Math.max(0, Math.min(max, target));

            // cancel any previous tween to avoid fighting animations
            if (_pillTween) cancelAnimationFrame(_pillTween);

            const start = bar.scrollLeft;
            const delta = dst - start;
            if (Math.abs(delta) < 1) return;               // already centered enough

            const dur = 220;                                // ms
            let t0 = null;

            function step(ts) {
                if (!t0) t0 = ts;
                const p = Math.min(1, (ts - t0) / dur);
                // easeOutQuad
                const e = 1 - (1 - p) * (1 - p);
                bar.scrollLeft = start + delta * e;
                if (p < 1) _pillTween = requestAnimationFrame(step);
            }
            _pillTween = requestAnimationFrame(step);
        }

        // Smooth-scroll within #app with a 70px offset
        const bar = document.querySelector('.pillbar');
        if (bar) {
            document.documentElement.style.setProperty('--pillbar-h', bar.offsetHeight + 'px');
        }



        function setActivePill(btn) {
            document.querySelectorAll('.pill').forEach(p => p.classList.remove('selected'));
            btn.classList.add('selected');
        }


        function scrollToSection(category) {
            const target = document.getElementById(idFor(category));
            if (!target) return;
            // It will scroll the right container automatically:
            // - on mobile (body scroll), or
            // - on desktop (if the element is inside a scroller, some browsers still use that)
            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // ===== Bottom Sheet Logic =====
        let SHEET = null, currentItem = null, qty = 1, selectedOptionIndex = null, selectedAdditions = new Set();

        function openProductSheet(p) {
            currentItem = normalizeForSheet(p);
            qty = 1; selectedOptionIndex = null; selectedAdditions.clear();

            const backdrop = document.getElementById('sheetBackdrop');
            SHEET = document.getElementById('productSheet');

            // hero
            const hero = document.getElementById('sheetImg');
            hero.src = currentItem.image || '';
            hero.alt = currentItem.name || '';
            hero.onerror = () => {
                hero.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="800" height="600"><rect width="100%" height="100%" fill="#ddd"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#888" font-family="sans-serif" font-size="24">No Image</text></svg>`);
            };

            document.getElementById('sheetName').textContent = (currentItem.name || '').toUpperCase();
            document.getElementById('sheetDesc').textContent = currentItem.description || '';

            renderModifiers(currentItem);

            document.getElementById('qtyValue').textContent = String(qty);
            updateAddPrice();

            backdrop.style.display = 'block';
            SHEET.classList.add('open');
            SHEET.setAttribute('aria-hidden', 'false');
            document.getElementById('app').style.overflow = 'hidden';

            document.getElementById('sheetClose').onclick = closeSheet;
            backdrop.onclick = closeSheet;
            document.getElementById('qtyMinus').onclick = () => { if (qty > 1) { qty--; document.getElementById('qtyValue').textContent = qty; updateAddPrice(); } };
            document.getElementById('qtyPlus').onclick = () => { qty++; document.getElementById('qtyValue').textContent = qty; updateAddPrice(); };
            document.getElementById('addToOrderBtn').onclick = onAddToOrderClicked;
            document.addEventListener('keydown', escHandler, { once: true });
        }

        function closeSheet() {
            const backdrop = document.getElementById('sheetBackdrop');
            if (!SHEET) return;
            SHEET.classList.remove('open');
            SHEET.setAttribute('aria-hidden', 'true');
            setTimeout(() => { backdrop.style.display = 'none'; }, 200);
            document.getElementById('app').style.overflow = 'auto';
            SHEET = null; currentItem = null;
        }
        function escHandler(e) { if (e.key === 'Escape') closeSheet(); }

        function normalizeForSheet(p) {
            const rawMods = Array.isArray(p.Options) ? p.Options : p.modifiers;
            const image = p.image || p.imageName || p.Image || '';

            let options = [], additions = [];
            if (Array.isArray(rawMods)) {
                for (const m of rawMods) {
                    const t = (m.type || m.Type || '').toLowerCase();
                    const name = m.OptionName || m.name || '';
                    const price = Number(m.ExtraPrice ?? m.price ?? 0);
                    if (t === 'option' || t === 'options') options.push({ name, price });
                    else if (t === 'addition' || t === 'additions') additions.push({ name, price });
                }
            }
            return {
                id: p.id ?? p.ProductId,
                name: p.name ?? p.Name ?? 'Item',
                image,
                description: p.description ?? p.Description ?? '',
                basePrice: Number(p.price ?? p.Price ?? 0),
                options, additions
            };
        }

        function renderModifiers(item) {
            // Options (single)
            const showOpts = item.options && item.options.length > 0;
            const optsBlock = document.getElementById('optionsBlock');
            const optsList = document.getElementById('optionsList');
            optsBlock.style.display = showOpts ? 'block' : 'none';
            optsList.innerHTML = '';
            if (showOpts) {
                item.options.forEach((opt, idx) => {
                    const row = document.createElement('div'); row.className = 'opt-card';
                    const radio = document.createElement('input'); radio.type = 'radio'; radio.name = 'opt'; radio.checked = (selectedOptionIndex === idx);
                    radio.onchange = () => { selectedOptionIndex = idx; updateAddPrice(); };
                    const label = document.createElement('div'); label.textContent = opt.name;
                    const extra = document.createElement('div'); extra.className = 'opt-price';
                    if (opt.price > 0) extra.textContent = `+£${opt.price.toFixed(2)}`;
                    row.append(radio, label, extra);
                    row.onclick = e => { if (e.target !== radio) { radio.checked = true; radio.onchange(); } };
                    optsList.appendChild(row);
                });
            }

            // Additions (multi)
            const showAdds = item.additions && item.additions.length > 0;
            const addsBlock = document.getElementById('additionsBlock');
            const addsList = document.getElementById('additionsList');
            addsBlock.style.display = showAdds ? 'block' : 'none';
            addsList.innerHTML = '';
            if (showAdds) {
                item.additions.forEach((add, idx) => {
                    const row = document.createElement('div'); row.className = 'opt-card';
                    const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = selectedAdditions.has(idx);
                    cb.onchange = () => { cb.checked ? selectedAdditions.add(idx) : selectedAdditions.delete(idx); updateAddPrice(); };
                    const label = document.createElement('div'); label.textContent = add.name;
                    const extra = document.createElement('div'); extra.className = 'opt-price';
                    if (add.price > 0) extra.textContent = `+£${add.price.toFixed(2)}`;
                    row.append(cb, label, extra);
                    row.onclick = e => { if (e.target !== cb) { cb.checked = !cb.checked; cb.onchange(); } };
                    addsList.appendChild(row);
                });
            }
        }

        function computeUnitPrice() {
            if (!currentItem) return 0;
            const optPrice = (selectedOptionIndex != null) ? (currentItem.options?.[selectedOptionIndex]?.price || 0) : 0;
            let adds = 0; selectedAdditions.forEach(idx => { adds += currentItem.additions?.[idx]?.price || 0; });
            return (currentItem.basePrice + optPrice + adds);
        }
        function updateAddPrice() { document.getElementById('addPrice').textContent = fmt.format(computeUnitPrice() * qty); }

        function onAddToOrderClicked() {
            if (!currentItem) return;

            const option = (selectedOptionIndex != null) ? currentItem.options[selectedOptionIndex] : null;
            const additions = [...selectedAdditions].map(i => currentItem.additions[i]).filter(Boolean);

            addToBasket({
                id: currentItem.id,
                name: currentItem.name,
                unitPrice: computeUnitPrice(),
                option, additions, image: currentItem.image
            }, qty);

            closeSheet();
        }

        // Boot + SW
        boot();
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(console.error);
        }

        // Temporary "View order" tap (replace with real basket sheet when ready)
        document.getElementById('bsCheckout').onclick = () => {
            const { total, quantity } = basketTotals();
            alert(`Proceed to pay ${fmt.format(total)} for ${quantity} item(s).`);
            // later: open payment sheet / navigate
        };
        // Open Basket Sheet
        function openBasketSheet() {
            const backdrop = document.getElementById('basketBackdropSheet');
            const sheet = document.getElementById('basketSheet');
            renderBasketSheetRows();

            document.getElementById('whenCard').addEventListener('click', openWhenModal);
            document.getElementById('addressCard').addEventListener('click', openAddrFullScreen);
            document.getElementById('payCard').addEventListener('click', openCardModal);

            // totals
            const { total } = basketTotals();
            document.getElementById('bsSubtotal').textContent = fmt.format(total);
            document.getElementById('bsTotal').textContent = fmt.format(total);
            updateInfoCards();
            updateDeliveryFeeUI();
            updateCheckoutCta();

            backdrop.style.display = 'block';
            sheet.classList.add('open');
            sheet.setAttribute('aria-hidden', 'false');
            // hide fixed bar to avoid overlap feel

            document.getElementById('app').style.overflow = 'hidden';

            document.getElementById('basketClose').onclick = closeBasketSheet;
            backdrop.onclick = closeBasketSheet;
            document.addEventListener('keydown', basketEsc, { once: true });
        }

        function closeBasketSheet() {
            const backdrop = document.getElementById('basketBackdropSheet');
            const sheet = document.getElementById('basketSheet');
            sheet.classList.remove('open');
            sheet.setAttribute('aria-hidden', 'true');
            setTimeout(() => { backdrop.style.display = 'none'; }, 200);
            document.getElementById('basketFixed').style.opacity = 1;
            document.getElementById('app').style.overflow = 'auto';
        }
        function basketEsc(e) { if (e.key === 'Escape') closeBasketSheet(); }
        document.getElementById('basketBtn').addEventListener('click', openBasketSheet);
        function renderBasketSheetRows() {
            const host = document.getElementById('basketContent');
            host.innerHTML = '';

            if (basket.length === 0) {
                host.innerHTML = '<p style="padding:12px;color:#666">Your basket is empty.</p>';
                return;
            }

            basket.forEach((row, idx) => {
                const div = document.createElement('div'); div.className = 'basket-row';

                const img = new Image();
                img.className = 'basket-thumb';
                img.src = row.image || '';
                img.alt = row.name || '';
                img.onerror = () => { img.src = ''; img.style.background = '#eee'; };

                const main = document.createElement('div'); main.className = 'basket-main';
                const name = document.createElement('div'); name.className = 'basket-name'; name.textContent = (row.name || '').toUpperCase();

                const mods = document.createElement('div'); mods.className = 'basket-mods';
                const opt = row.option ? row.option.name : '';
                const adds = (row.additions || []).map(a => a.name).join(', ');
                mods.textContent = [opt, adds].filter(Boolean).join(' • ');

                const line = document.createElement('div'); line.className = 'basket-line';
                line.textContent = fmt.format(row.unitPrice * row.qty);

                main.append(name, mods, line);

                const ctrls = document.createElement('div'); ctrls.className = 'basket-ctrls';

                const minus = document.createElement('button');
                minus.textContent = row.qty === 1 ? '🗑' : '−';
                if (row.qty === 1) minus.classList.add('basket-trash');
                minus.onclick = () => decrementRow(idx);

                const qty = document.createElement('div');
                qty.textContent = row.qty;
                qty.style.minWidth = '20px';
                qty.style.textAlign = 'center';
                qty.style.fontWeight = '800';

                const plus = document.createElement('button');
                plus.textContent = '+';
                plus.onclick = () => incrementRow(idx);

                ctrls.append(minus, qty, plus);

                div.append(img, main, ctrls);
                host.append(div);
            });
        }

        function incrementRow(i) {
            basket[i].qty += 1;
            saveBasket();
            renderBasketSheetRows();
            const { total } = basketTotals();
            document.getElementById('bsSubtotal').textContent = fmt.format(total);
            document.getElementById('bsTotal').textContent = fmt.format(total);
            updateBasketBar();
        }

        function decrementRow(i) {
            if (basket[i].qty > 1) {
                basket[i].qty -= 1;
            } else {
                basket.splice(i, 1);
            }
            saveBasket();
            renderBasketSheetRows();
            const { total } = basketTotals();
            document.getElementById('bsSubtotal').textContent = fmt.format(total);
            document.getElementById('bsTotal').textContent = fmt.format(total);
            updateBasketBar();

            // auto-close if emptied
            if (basket.length === 0) closeBasketSheet();
        }

        // ===== When & Address state (persist to localStorage) =====
        let scheduledISO = localStorage.getItem('scheduledForISO') || '';   // e.g., "2025-08-22T18:30"
        let addressText = localStorage.getItem('customerAddress') || '';
        // Show current WHEN + ADDRESS on the cards
        function updateInfoCards() {
            const whenLbl = document.getElementById('whenValue');
            whenLbl.textContent = scheduledISO ? formatWhenDisplay(scheduledISO) : 'ASAP';

            const addrLbl = document.getElementById('addressValue');
            addressText = localStorage.getItem('customerAddress') || addressText || '';
            addrLbl.textContent = addressText ? addressText : 'Add delivery address';
        }

        // Insert or update a Delivery row and adjust totals
        function updateDeliveryFeeUI() {
            const info = computeDeliveryInfo();
            const subtotal = basketTotals().total;

            // find footer + total row
            const footer = document.querySelector('.basket-footer');
            const totalRow = document.getElementById('bsTotal')?.parentElement;

            // ensure a delivery row exists
            let row = document.getElementById('bsDeliveryRow');
            if (!row) {
                row = document.createElement('div');
                row.className = 'basket-tot';
                row.id = 'bsDeliveryRow';
                // insert before total row
                if (totalRow) footer.insertBefore(row, totalRow);
                else footer.appendChild(row);
            }

            if (!info) {
                // no coords yet → hide row and set total=subtotal
                row.style.display = 'none';
                document.getElementById('bsSubtotal').textContent = fmt.format(subtotal);
                document.getElementById('bsTotal').textContent = fmt.format(subtotal);
                return;
            }

            // show row with "Delivery (X.X mi, zone N)"
            const milesStr = info.miles.toFixed(1);
            row.innerHTML = `<span>Delivery (${milesStr} mi)</span><span id="bsDeliveryVal">${fmt.format(info.fee)}</span>`;
            row.style.display = 'flex';

            // update totals
            document.getElementById('bsSubtotal').textContent = fmt.format(subtotal);
            document.getElementById('bsTotal').textContent = fmt.format(subtotal + info.fee);

        }
        const LONDON_TZ = 'Europe/London';
        function nowLondon() { return new Date(new Date().toLocaleString('en-GB', { timeZone: LONDON_TZ })); }

        function todayStart() {
            const n = new Date();
            return new Date(n.getFullYear(), n.getMonth(), n.getDate());
        }

        // round up a Date to the next N-minute boundary
        function roundUp(date, minutes = 15) {
            const d = new Date(date);
            const ms = minutes * 60 * 1000;
            return new Date(Math.ceil(d.getTime() / ms) * ms);
        }

        // Build next 7 days with stable labels (Today / Tomorrow / Wed 27/08)
        function buildDayOptions() {
            const base = todayStart();
            const days = [];
            const now = new Date();

            for (let i = 0; i < 7; i++) {
                const d = new Date(base.getFullYear(), base.getMonth(), base.getDate() + i);

                // ⏰ Skip "Today" if it's after 7pm
                if (i === 0 && now.getHours() >= 19) continue;

                let label = d.toLocaleDateString('en-GB', {
                    weekday: 'long',
                    day: '2-digit',
                    month: '2-digit'
                });
                if (i === 0) label = 'Today';
                if (i === 1 || (i === 0 && now.getHours() >= 19)) label = 'Tomorrow';

                days.push({ date: d, label });
            }
            return days;
        }

        // 15-min slots 08:00–20:00; if today => min start = now + 60min rounded
        function buildTimeSlots(dayDate) {
            const slots = [];
            const start = new Date(dayDate.getFullYear(), dayDate.getMonth(), dayDate.getDate(), 8, 0, 0, 0);
            const end = new Date(dayDate.getFullYear(), dayDate.getMonth(), dayDate.getDate(), 20, 0, 0, 0);

            const now = new Date();
            const isToday = dayDate.toDateString() === now.toDateString();
            let first = new Date(start);
            if (isToday) {
                const min = roundUp(new Date(now.getTime() + 60 * 60 * 1000), 15);
                if (min > first) first = min;
            }
            if (first > end) return slots;

            for (let t = new Date(first); t <= end; t = new Date(t.getTime() + 15 * 60 * 1000)) {
                slots.push({ date: new Date(t), label: t.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) });
            }
            return slots;
        }

        // Display helper for the WHEN card
        function formatWhenDisplay(iso) {
            try {
                const d = new Date(iso);
                if (isNaN(d)) return 'ASAP';
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const target = new Date(d.getFullYear(), d.getMonth(), d.getDate());
                const diff = Math.round((target - today) / 86400000);
                const hm = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                if (diff === 0) return `Today at ${hm}`;
                if (diff === 1) return `Tomorrow at ${hm}`;
                const dayLbl = d.toLocaleDateString('en-GB', { weekday: 'long', day: '2-digit', month: '2-digit' });
                return `${dayLbl} at ${hm}`;
            } catch { return 'ASAP'; }
        }


        function openWhenModal() {
            const m = document.getElementById('whenModal');
            const b = document.getElementById('whenBackdrop');
            const daySel = document.getElementById('daySelect');
            const timeSel = document.getElementById('timeSelect');
            const asap = document.getElementById('whenAsap');
            const later = document.getElementById('whenLater');
            const pickerRow = document.getElementById('pickerRow');
            const summary = document.getElementById('whenSummary');

            // set ASAP hint if you want to compute zone → simple static for now
            document.getElementById('asapHint').textContent = 'Usually within 40–50 min';

            // populate days
            const days = buildDayOptions();
            daySel.innerHTML = '';
            days.forEach((d, i) => {
                const opt = document.createElement('option');
                opt.value = String(i);
                opt.textContent = d.label;
                daySel.appendChild(opt);
            });

            // initial mode + selected indices from persisted ISO (if any)
            let selectedDayIndex = 0;
            let selectedTimeIndex = 0;
            if (scheduledISO) {
                later.checked = true; asap.checked = false;
                const saved = new Date(scheduledISO);
                // find day index
                selectedDayIndex = days.findIndex(d => d.date.toDateString() === saved.toDateString());
                if (selectedDayIndex < 0) selectedDayIndex = 0;
            } else {
                asap.checked = true; later.checked = false;
            }

            // build times for selected day
            function refreshTimes() {
                const idx = Number(daySel.value);
                const slots = buildTimeSlots(days[idx].date);
                timeSel.innerHTML = '';
                slots.forEach((s, i) => {
                    const opt = document.createElement('option');
                    opt.value = s.date.toISOString();
                    opt.textContent = s.label;
                    timeSel.appendChild(opt);
                });
                // choose default time
                if (scheduledISO) {
                    const match = Array.from(timeSel.options).findIndex(o => o.value.slice(0, 16) === scheduledISO.slice(0, 16));
                    timeSel.selectedIndex = match >= 0 ? match : 0;
                } else {
                    timeSel.selectedIndex = 0;
                }
                selectedTimeIndex = timeSel.selectedIndex;
                // summary
                const iso = timeSel.options[selectedTimeIndex]?.value;
                summary.textContent = iso ? formatWhenDisplay(iso) : 'Pick a time';
            }

            daySel.value = String(selectedDayIndex);
            refreshTimes();

            // enable/disable picker row
            const setMode = () => {
                pickerRow.style.display = later.checked ? 'flex' : 'none';
            };
            setMode();

            daySel.onchange = () => refreshTimes();
            timeSel.onchange = () => {
                selectedTimeIndex = timeSel.selectedIndex;
                const iso = timeSel.options[selectedTimeIndex]?.value;
                summary.textContent = iso ? formatWhenDisplay(iso) : 'Pick a time';
            };
            asap.onchange = setMode;
            later.onchange = setMode;

            // open
            b.style.display = 'block'; m.classList.add('open'); m.setAttribute('aria-hidden', 'false');
            document.getElementById('app').style.overflow = 'hidden';

            // actions
            document.getElementById('whenCancel').onclick = closeWhenModal;
            b.onclick = closeWhenModal;
            document.getElementById('whenSave').onclick = () => {
                if (asap.checked) {
                    scheduledISO = '';
                    localStorage.removeItem('scheduledForISO');
                } else {
                    const iso = timeSel.options[timeSel.selectedIndex]?.value;
                    if (!iso) { alert('Pick a time'); return; }
                    scheduledISO = iso;
                    localStorage.setItem('scheduledForISO', scheduledISO);
                }
                updateInfoCards();
                closeWhenModal();
            };
        }

        function closeWhenModal() {
            const m = document.getElementById('whenModal');
            const b = document.getElementById('whenBackdrop');
            m.classList.remove('open'); m.setAttribute('aria-hidden', 'true');
            setTimeout(() => { b.style.display = 'none'; }, 200);
            document.getElementById('app').style.overflow = 'auto';
        }
        document.getElementById('whenCard').addEventListener('click', openWhenModal);
        document.getElementById('addressCard').addEventListener('click', openAddrFullScreen);

        // keep the labels up to date when opening the sheet
        updateInfoCards();


        function ukPhonePreview(raw) {
            const filtered = (raw || '').trim().replace(/[^\d+]/g, '');
            if (!filtered) return { preview: '+44', e164: null, isValid: false };
            let candidate = filtered;
            if (filtered[0] === '+') candidate = filtered;
            else if (filtered[0] === '0') candidate = '+44' + filtered.slice(1);
            else candidate = '+44' + filtered;
            const valid = /^\+[1-9]\d{7,14}$/.test(candidate);
            return { preview: candidate, e164: valid ? candidate : null, isValid: valid };
        }
        function isValidEmailSimple(s) { return /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(s || ''); }
        function shake(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); }
        function openAddrFullScreen() {
            const b = document.getElementById('addrFsBackdrop');
            const s = document.getElementById('addrFsSheet');

            // prefill from localStorage
            const addr = JSON.parse(localStorage.getItem('savedAddressJSON') || 'null') || {};
            document.getElementById('af_postcode').value = addr.postcode || '';
            document.getElementById('af_street').value = addr.streetName || '';
            document.getElementById('af_number').value = addr.streetNumber || '';
            document.getElementById('af_instr').value = addr.instructions || '';
            document.getElementById('af_name').value = localStorage.getItem('userName') || (addr.name || '');
            document.getElementById('af_email').value = localStorage.getItem('userEmail') || '';
            document.getElementById('af_phone').value = localStorage.getItem('userPhone') || (addr.phone || '');

            // phone hint
            const ph = ukPhonePreview(document.getElementById('af_phone').value);
            document.getElementById('af_phone_hint').textContent = `Will send as ${ph.preview}`;

            b.style.display = 'block'; s.classList.add('open'); s.setAttribute('aria-hidden', 'false');
            document.getElementById('app').style.overflow = 'hidden';

            document.getElementById('addrFsBack').onclick = closeAddrFullScreen;
            b.onclick = closeAddrFullScreen;

            document.getElementById('af_phone').oninput = (e) => {
                const pr = ukPhonePreview(e.target.value);
                document.getElementById('af_phone_hint').textContent = `Will send as ${pr.preview}`;
            };

            initCustomAutocomplete();
            // (optional) also create/refresh a new token per session:

            document.getElementById('addrFsSave').onclick = async () => {
                const wrap = document.getElementById('addrFormWrapper');

                const postcode = document.getElementById('af_postcode');
                const street = document.getElementById('af_street');
                const number = document.getElementById('af_number');
                const instr = document.getElementById('af_instr');
                const name = document.getElementById('af_name');
                const email = document.getElementById('af_email');
                const phone = document.getElementById('af_phone');

                // reset errors
                [postcode, street, number, name, email, phone].forEach(i => i.classList.remove('error'));

                const phoneInfo = ukPhonePreview(phone.value);
                const hasErrors =
                    !postcode.value.trim() ||
                    !street.value.trim() ||
                    !number.value.trim() ||
                    !name.value.trim() ||
                    !isValidEmailSimple(email.value) ||
                    !phoneInfo.isValid;

                if (hasErrors) {
                    if (!postcode.value.trim()) postcode.classList.add('error');
                    if (!street.value.trim()) street.classList.add('error');
                    if (!number.value.trim()) number.classList.add('error');
                    if (!name.value.trim()) name.classList.add('error');
                    if (!isValidEmailSimple(email.value)) email.classList.add('error');
                    if (!phoneInfo.isValid) phone.classList.add('error');
                    shake(wrap);
                    return;
                }

                // Ensure we have lat/lng (use Google if user typed manually)
                if (addrLat == null || addrLng == null) {
                    const line = `${postcode.value} ${street.value} ${number.value}`.trim();
                    const { lat, lng } = await geocodeIfMissing(line);
                    addrLat = lat; addrLng = lng;
                }

                // If still missing coords, block save
                if (addrLat == null || addrLng == null) {
                    alert('We could not locate this address. Please select a suggestion or refine the address.');
                    return;
                }

                // Distance check: Central London → address
                const miles = milesBetween(LONDON_CENTER, { lat: addrLat, lng: addrLng });
                if (miles > 20) {
                    alert('Only available within 20 miles of Central London.');
                    return;
                }

                // Build + persist
                const savedAddress = {
                    streetName: street.value.trim(),
                    streetNumber: number.value.trim(),
                    postcode: postcode.value.trim().toUpperCase(),
                    instructions: instr.value.trim(),
                    name: name.value.trim(),
                    email: email.value.trim(),
                    phone: phoneInfo.e164,
                    lat: addrLat,
                    lng: addrLng
                };

                localStorage.setItem('savedAddressJSON', JSON.stringify(savedAddress));
                localStorage.setItem('customerAddress',
                    `${savedAddress.postcode} ${savedAddress.streetName} ${savedAddress.streetNumber}`.trim());
                localStorage.setItem('userName', savedAddress.name);
                localStorage.setItem('userEmail', savedAddress.email);
                localStorage.setItem('userPhone', phoneInfo.e164);

                addressText = localStorage.getItem('customerAddress') || '';
                updateInfoCards();
                updateDeliveryFeeUI();
                updateCheckoutCta();
                closeAddrFullScreen();
            };
        }
        function closeAddrFullScreen() {
            const b = document.getElementById('addrFsBackdrop');
            const s = document.getElementById('addrFsSheet');
            s.classList.remove('open'); s.setAttribute('aria-hidden', 'true');
            setTimeout(() => { b.style.display = 'none'; }, 200);
            document.getElementById('app').style.overflow = 'auto';
        }

        // Globals to store the geocoded coordinates from the chosen place
        let addrLat = null, addrLng = null;

        // Extract a component by type from address_components[]
        function comp(components, type) {
            const c = components.find(x => (x.types || []).includes(type));
            return c ? c.long_name : '';
        }

        // Try to split a single line like "42A Brick Lane" into number + street
        function splitNumberStreet(line) {
            const m = String(line || '').trim().match(/^(\d+[A-Za-z\-\/]*)\s+(.+)$/);
            return m ? { number: m[1], street: m[2] } : { number: '', street: line || '' };
        }

        // Called by Google script when loaded
        function initPlaces() {
            if (!window.google || !google.maps || !google.maps.places) return;

            const input = document.getElementById('af_postcode');
            if (!input) return;

            // Bias to GB; types 'geocode' covers addresses + postcodes
            const ac = new google.maps.places.Autocomplete(input, {
                fields: ['address_components', 'geometry', 'formatted_address'],
                componentRestrictions: { country: 'gb' },
                types: ['geocode']
            });

            ac.addListener('place_changed', () => {
                const place = ac.getPlace();
                if (!place || !place.address_components) return;

                // Coordinates
                const geom = place.geometry && place.geometry.location;
                addrLat = geom ? geom.lat() : null;
                addrLng = geom ? geom.lng() : null;

                // Parse components
                const postcode = comp(place.address_components, 'postal_code');
                const route = comp(place.address_components, 'route');             // street name
                const number = comp(place.address_components, 'street_number');     // house/flat
                const sublocal = comp(place.address_components, 'sublocality') || comp(place.address_components, 'neighborhood');
                const locality = comp(place.address_components, 'locality');

                // Fill the fields
                const f_post = document.getElementById('af_postcode');
                const f_st = document.getElementById('af_street');
                const f_num = document.getElementById('af_number');

                if (postcode) f_post.value = postcode.toUpperCase();

                if (route) {
                    f_st.value = route;
                    if (number) {
                        f_num.value = number;
                    } else {
                        // Try to infer number from the typed value (e.g., "42A Brick Lane")
                        const inferred = splitNumberStreet(input.value);
                        if (inferred.number && !f_num.value) f_num.value = inferred.number;
                    }
                } else {
                    // If we only got postcode, leave street/number blank for manual entry
                    // (You can geocode again later if needed)
                }

                // Optionally: compose a friendly single-line address in the field the user typed
                // input.value = place.formatted_address || input.value;

                // You could also show a small confirmation toast here if you want
            });
        }

        function geocodeIfMissing(addrLine) {
            return new Promise((resolve) => {
                if (addrLat != null && addrLng != null) return resolve({ lat: addrLat, lng: addrLng });
                if (!window.google || !google.maps || !google.maps.Geocoder) return resolve({ lat: null, lng: null });
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: addrLine, componentRestrictions: { country: 'GB' } }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const loc = results[0].geometry.location;
                        resolve({ lat: loc.lat(), lng: loc.lng() });
                    } else {
                        resolve({ lat: null, lng: null });
                    }
                });
            });
        }

        let acInstance = null;   // keep a single Autocomplete instance


        function onPlaceChosen() {
            const place = acInstance.getPlace?.();
            if (!place || !place.address_components) return;

            // coords
            const geom = place.geometry && place.geometry.location;
            addrLat = geom ? geom.lat() : null;
            addrLng = geom ? geom.lng() : null;

            // helpers
            const postcode = comp(place.address_components, 'postal_code');
            const route = comp(place.address_components, 'route');          // street
            const number = comp(place.address_components, 'street_number');  // house/flat

            const f_post = document.getElementById('af_postcode');
            const f_st = document.getElementById('af_street');
            const f_num = document.getElementById('af_number');

            if (postcode) f_post.value = postcode.toUpperCase();

            if (route) {
                f_st.value = route;
                if (number) {
                    f_num.value = number;
                } else {
                    // try infer from what the user typed: "42A Brick Lane"
                    const inferred = splitNumberStreet(f_post.value);
                    if (inferred.number && !f_num.value) f_num.value = inferred.number;
                    if (inferred.street && !f_st.value) f_st.value = inferred.street;
                }
            }
        }
        // ---------- Google Places custom autocomplete ----------
        let acService = null;
        let detailsService = null;
        let acMenuEl = null;
        let acInputEl = null;
        let acToken = null;  // session token is optional, improves billing grouping

        function ensurePlacesServices() {
            if (!window.google?.maps?.places) return false;
            if (!acService) acService = new google.maps.places.AutocompleteService();
            if (!detailsService) detailsService = new google.maps.places.PlacesService(document.createElement('div'));
            return true;
        }

        function openAcMenu() { acMenuEl.style.display = 'block'; }
        function closeAcMenu() { acMenuEl.style.display = 'none'; acMenuEl.innerHTML = ''; }

        function renderPredictions(preds) {
            if (!preds || !preds.length) { closeAcMenu(); return; }
            acMenuEl.innerHTML = '';
            preds.forEach(pred => {
                const div = document.createElement('div'); div.className = 'ac-item';
                const icon = document.createElement('div'); icon.className = 'ac-icon'; icon.textContent = '📍';
                const main = document.createElement('div'); main.className = 'ac-main';
                const p1 = document.createElement('div'); p1.className = 'ac-primary'; p1.textContent = pred.structured_formatting?.main_text || pred.description;
                const p2 = document.createElement('div'); p2.className = 'ac-secondary'; p2.textContent = pred.structured_formatting?.secondary_text || '';
                main.append(p1, p2);
                div.append(icon, main);
                div.onclick = () => choosePrediction(pred);
                acMenuEl.append(div);
            });
            openAcMenu();
        }

        function choosePrediction(pred) {
            closeAcMenu();
            if (!ensurePlacesServices()) return;
            // New Places Details via old PlacesService
            detailsService.getDetails({
                placeId: pred.place_id,
                fields: ['address_component', 'geometry', 'formatted_address'] // old field names; works in JS API v3.55+
            }, (place, status) => {
                if (status !== google.maps.places.PlacesServiceStatus.OK || !place) return;

                // coords
                const loc = place.geometry?.location;
                addrLat = loc ? loc.lat() : null;
                addrLng = loc ? loc.lng() : null;

                // components
                const comps = place.address_components || place.addressComponent || [];
                const postcode = comp(comps, 'postal_code') || '';
                const route = comp(comps, 'route') || '';
                const number = comp(comps, 'street_number') || '';

                const f_post = document.getElementById('af_postcode');
                const f_st = document.getElementById('af_street');
                const f_num = document.getElementById('af_number');

                if (postcode) f_post.value = postcode.toUpperCase();
                if (route) f_st.value = route;
                if (number) f_num.value = number;

                // If still missing number, try infer from what the user typed
                if (!number) {
                    const inferred = splitNumberStreet(acInputEl.value);
                    if (inferred.number && !f_num.value) f_num.value = inferred.number;
                    if (inferred.street && !f_st.value) f_st.value = inferred.street;
                }
            });
        }

        // simple debounce
        function debounce(fn, ms) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }

        const onAcInput = debounce(() => {
            if (!ensurePlacesServices()) return;
            const q = acInputEl.value.trim();
            if (!q) { closeAcMenu(); return; }

            // optional session token
            if (!acToken) acToken = new google.maps.places.AutocompleteSessionToken();

            acService.getPlacePredictions({
                input: q,
                componentRestrictions: { country: 'gb' },
                // types: ['address'], // stricter than 'geocode' if you prefer
                sessionToken: acToken
            }, (preds, status) => {
                if (status !== google.maps.places.PlacesServiceStatus.OK) { closeAcMenu(); return; }
                renderPredictions(preds);
            });
        }, 120);

        // Initialize when the address full-screen opens (so input exists)
        function initCustomAutocomplete() {
            acInputEl = document.getElementById('af_postcode');
            acMenuEl = document.getElementById('acMenu');
            if (!acInputEl || !acMenuEl) return;
            acInputEl.setAttribute('autocomplete', 'off');
            acInputEl.addEventListener('input', onAcInput);
            // close menu on outside click / ESC
            document.addEventListener('click', (e) => {
                if (!acMenuEl.contains(e.target) && e.target !== acInputEl) closeAcMenu();
            });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeAcMenu(); });
        }

        // Central London reference
        const LONDON_CENTER = { lat: 51.509865, lng: -0.118092 };

        // Haversine distance in miles
        function milesBetween(a, b) {
            const R = 6371000; // meters
            const toRad = d => d * Math.PI / 180;
            const dLat = toRad(b.lat - a.lat);
            const dLng = toRad(b.lng - a.lng);
            const la1 = toRad(a.lat), la2 = toRad(b.lat);
            const h = Math.sin(dLat / 2) ** 2 + Math.cos(la1) * Math.cos(la2) * Math.sin(dLng / 2) ** 2;
            const meters = 2 * R * Math.asin(Math.sqrt(h));
            return meters / 1609.344;
        }

        // ---- Shop coordinates (defaults to Beigel Bake) ----
        const SHOP_DEFAULT = { lat: 51.52463865220368, lng: -0.07180371846255229 };
        function getShopCoords() {
            const lat = parseFloat(localStorage.getItem('shopLat'));
            const lng = parseFloat(localStorage.getItem('shopLng'));
            if (Number.isFinite(lat) && Number.isFinite(lng)) return { lat, lng };
            return SHOP_DEFAULT;
        }

        // ---- Delivery fees table (zones 0..20) ----
        const DELIVERY_FEES = [
            6.00, 6.00, 8.70, 12.50, 14.06, 17.12, 21.28, 22.39, 24.36, 26.30,
            28.30, 30.26, 31.80, 33.34, 34.88, 36.41, 37.95, 39.48, 41.02, 42.56, 42.56
        ];

        // Haversine in miles (you already have milesBetween for London; reuse here)
        function milesBetween(a, b) {
            const R = 6371000; // meters
            const toRad = d => d * Math.PI / 180;
            const dLat = toRad(b.lat - a.lat);
            const dLng = toRad(b.lng - a.lng);
            const la1 = toRad(a.lat), la2 = toRad(b.lat);
            const h = Math.sin(dLat / 2) ** 2 + Math.cos(la1) * Math.cos(la2) * Math.sin(dLng / 2) ** 2;
            const meters = 2 * R * Math.asin(Math.sqrt(h));
            return meters / 1609.344;
        }

        // Compute distance/zone/fee from shop → current address coords
        function computeDeliveryInfo() {
            // prefer fresh globals set by autocomplete; else from savedAddressJSON
            let lat = addrLat, lng = addrLng;
            const saved = JSON.parse(localStorage.getItem('savedAddressJSON') || 'null');
            if ((lat == null || lng == null) && saved && Number.isFinite(saved.lat) && Number.isFinite(saved.lng)) {
                lat = saved.lat; lng = saved.lng;
            }
            if (lat == null || lng == null) return null;

            const shop = getShopCoords();
            const miles = milesBetween(shop, { lat, lng });
            // zone = floor(miles), clamp to [0, fees.length-1]
            const zone = Math.max(0, Math.min(DELIVERY_FEES.length - 1, Math.floor(miles)));
            const fee = DELIVERY_FEES[zone];
            return { miles, zone, fee };
        }

        document.getElementById('af_postcode').addEventListener('input', e => {
            e.target.value = e.target.value.toUpperCase();
        });

        // ===== Stripe client-side setup =====
        const STRIPE_PUB_KEY = 'pk_live_51H5URzFZIwZSNufssK4R7BjLhpqxHVcfmEZVH8Tg74MAHMA20RfkYhIfbwFjDWJ55KzHWkOhEcqVWhIO2VShjOcU00Tslmi1XT'; // 👈 REPLACE ME
        let stripe = null, elements = null, cardElement = null;

        function ensureStripeMounted() {
            if (!window.Stripe) { console.error('Stripe.js not loaded'); return false; }
            if (!stripe) stripe = Stripe(STRIPE_PUB_KEY);
            if (!elements) elements = stripe.elements({ appearance: { theme: 'stripe' } });
            if (!cardElement) {
                cardElement = elements.create('card', {
                    hidePostalCode: true,
                    style: {
                        base: {
                            fontSize: '16px',
                            lineHeight: '24px',
                            '::placeholder': { color: '#9ca3af' }
                        },
                        invalid: { color: '#b00020' }
                    }
                });
                cardElement.mount('#cardMount');
                cardElement.on('change', (e) => {
                    document.getElementById('cardErrors').textContent = e.error ? e.error.message : '';
                });
            }
            return true;
        }

        // Compute grand total (subtotal + delivery) using your fee logic
        function computeGrand() {
            const subtotal = basketTotals().total;
            const info = computeDeliveryInfo(); // { miles, zone, fee }
            const delivery = info ? round2(info.fee) : 0;
            return { subtotal, delivery, grand: round2(subtotal + delivery) };
        }

        // Open/close the card sheet
        function openCardModal() {
            lockCardViewport();
            const b = document.getElementById('cardBackdrop');
            const m = document.getElementById('cardModal');

            // label the Pay button with the grand total
            const { grand } = computeGrand();

            b.style.display = 'block';
            m.classList.add('open');
            m.setAttribute('aria-hidden', 'false');
            document.getElementById('app').style.overflow = 'hidden';

            // mount Stripe if needed
            const tryMount = () => {
                if (ensureStripeMounted()) return;
                setTimeout(tryMount, 120);
            };
            tryMount();

            document.getElementById('cardCancel').onclick = closeCardModal;
            b.onclick = closeCardModal;
            document.getElementById('cardSaveBtn').onclick = onCardSave;

        }

        function closeCardModal() {
            const b = document.getElementById('cardBackdrop');
            const m = document.getElementById('cardModal');
            m.classList.remove('open');
            m.setAttribute('aria-hidden', 'true');
            setTimeout(() => { b.style.display = 'none'; }, 200);
            document.getElementById('app').style.overflow = 'auto';
        }

        // Full card payment flow using your /create-payment-intent
        async function onCardPay() {
            const errs = document.getElementById('cardErrors');
            errs.textContent = '';

            try {
                if (!ensureStripeMounted()) throw new Error('Stripe is not ready');

                // 1) Create PaymentMethod from the card Element
                const pmRes = await stripe.createPaymentMethod({ type: 'card', card: cardElement });
                if (pmRes.error) throw pmRes.error;

                // 2) Figure out amount (minor units) and currency
                const { grand } = computeGrand();
                const amount = Math.round(grand * 100);
                const currency = 'gbp';

                // 3) Ask your backend to create + confirm PI with that PaymentMethod
                const resp = await fetch('/create-payment-intent', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        amount,
                        currency,
                        paymentMethod: pmRes.paymentMethod.id,
                        description: 'Web Card Payment',
                        metadata: { source: 'pwa' }
                    })
                });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data?.error || 'Payment failed');

                // 4) If backend confirmed successfully, we’re done
                // Optionally: you can now proceed to submitOrder using PI id from `data.id`
                closeCardModal();
                alert('Payment authorized ✔️');  // replace with your order submission flow
            } catch (e) {
                errs.textContent = e.message || String(e);
            }
        }
        function lockCardViewport() {
            // layout viewport height (doesn’t shrink with keyboard)
            const lockH = window.innerHeight;
            document.documentElement.style.setProperty('--card-lock-h', `${lockH}px`);
            document.documentElement.classList.add('card-locked');
        }

        // unlock when closing
        function unlockCardViewport() {
            document.documentElement.classList.remove('card-locked');
            // refresh live visual height for the next time
            const vv = window.visualViewport;
            const h = vv ? vv.height : window.innerHeight;
            document.documentElement.style.setProperty('--card-h', `${h}px`);
        }

        // keep --card-h updated when NOT locked
        (function trackCardVV() {
            const update = () => {
                if (document.documentElement.classList.contains('card-locked')) return;
                const vv = window.visualViewport;
                const h = vv ? vv.height : window.innerHeight;
                document.documentElement.style.setProperty('--card-h', `${h}px`);
            };
            window.addEventListener('resize', update, { passive: true });
            if (window.visualViewport) {
                visualViewport.addEventListener('resize', update);
                visualViewport.addEventListener('scroll', update);
            }
        })();
        // --- rounding helper
        function round2(n) { return Math.round((n + Number.EPSILON) * 100) / 100; }

        // --- basic fee: just return the raw fee
        function calcDeliveryFee(raw, subtotal, isDelivery) {
            return isDelivery ? round2(raw) : 0;
        }

        // Store a minimal card descriptor for UI
        function setSavedCardLabel(pm) {
            const brand = pm.card?.brand || 'Card';
            const last4 = pm.card?.last4 ? ` •••• ${pm.card.last4}` : '';
            document.getElementById('payMethodLabel').textContent = `${brand}${last4}`;
        }

        async function onCardSave() {
            const errs = document.getElementById('cardErrors');
            errs.textContent = '';

            try {
                if (!ensureStripeMounted()) throw new Error('Stripe is not ready');

                // Create a PaymentMethod (no payment yet)
                const res = await stripe.createPaymentMethod({ type: 'card', card: cardElement });
                if (res.error) throw res.error;

                const pm = res.paymentMethod;

                // Persist just what you need; you can store the full pm if you want
                localStorage.setItem('savedPaymentMethodId', pm.id);
                localStorage.setItem('savedPaymentMethodCard', JSON.stringify({
                    brand: pm.card?.brand || '',
                    last4: pm.card?.last4 || ''
                }));

                setSavedCardLabel(pm);
                closeCardModal();
                updateCheckoutCta();
                // Optional toast
                // alert('Card saved');

            } catch (e) {
                errs.textContent = e.message || String(e);
            }
        }

        (function restoreSavedCard() {
            try {
                const info = JSON.parse(localStorage.getItem('savedPaymentMethodCard') || 'null');
                if (info && (info.brand || info.last4)) {
                    document.getElementById('payMethodLabel').textContent =
                        `${info.brand || 'Card'}${info.last4 ? ' •••• ' + info.last4 : ''}`;
                }
            } catch { }
        })();

        function hasSavedAddress() {
            try {
                const a = JSON.parse(localStorage.getItem('savedAddressJSON') || 'null');
                return !!(a && a.postcode && a.streetName && a.streetNumber);
            } catch { return false; }
        }
        function hasSavedCard() {
            return !!localStorage.getItem('savedPaymentMethodId');
        }

        // set the footer CTA and click behavior
        function updateCheckoutCta() {
            const btn = document.getElementById('bsCheckout');
            if (!btn) return;
            const fresh = btn.cloneNode(true);
            btn.parentNode.replaceChild(fresh, btn);
            const cta = document.getElementById('bsCheckout');

            if (!hasSavedAddress()) { cta.textContent = 'ADD ADDRESS'; cta.onclick = openAddrFullScreen; return; }
            if (!hasSavedCard()) { cta.textContent = 'ADD CARD'; cta.onclick = openCardModal; return; }

            // ✅ both saved → submit to backend, then push confirmation view on success
            cta.textContent = 'CONFIRM ORDER';
            cta.onclick = submitOrder;   // <-- changed from openConfirmationView
        }

        function logDbg(...a) { try { console.log('[CONF]', ...a); } catch { } }

        function openConfirmationView() {
            const v = document.getElementById('confirmView');
            const back = document.getElementById('confirmBack');
            const phone = document.querySelector('.app-col');

            logDbg('openConfirmationView called');
            if (!v) { logDbg('❌ confirmView not found'); return; }
            if (!phone) { logDbg('❌ .app-col not found'); return; }

            if (typeof closeBasketSheet === 'function') {
                logDbg('closing basket sheet…');
                closeBasketSheet();
            }
            hideBasketBar();

            const rawLocal = localStorage.getItem('lastOrderId');
            const qsId = new URLSearchParams(location.search).get('orderId');
            const orderId = getActiveOrderId() || parseInt(rawLocal || '0', 10) || parseInt(qsId || '0', 10) || 0;
            logDbg('orderId resolved =', orderId, '(local=', rawLocal, ', qs=', qsId, ')');

            // Push the view in 250ms (mimic iOS)
            setTimeout(() => {
                try {
                    phone.classList.add('push-left');
                    v.style.display = 'grid';
                    requestAnimationFrame(() => v.classList.add('open'));
                    v.setAttribute('aria-hidden', 'false');
                    document.getElementById('app').style.overflow = 'hidden';
                    if (back) back.onclick = closeConfirmationView;

                    // 🔎 Don’t block the transition on the map; initialize it in the background.
                    logDbg('kicking off initConfirmMapBase…');
                    Promise.resolve()
                        .then(() => initConfirmMapBase?.())
                        .then(() => logDbg('initConfirmMapBase done'))
                        .catch(err => logDbg('initConfirmMapBase error:', err?.message || err));

                    if (orderId > 0) {
                        logDbg('startConfirmPolling…');
                        startConfirmPolling(orderId);
                    } else {
                        logDbg('No valid orderId, skip polling.');
                        // Still render the shell so the screen has content
                        renderConfirmationShell(0);

                        if (orderId > 0) {
                            logDbg('startConfirmPolling…');
                            startConfirmPolling(orderId);
                        } else {
                            logDbg('No valid orderId, skip polling.');
                            // show the screen anyway
                            renderConfirmationShell(0);
                            +         // fill ETA/status from scheduled time (or ASAP)
                                +         renderConfirmation(0, null);
                        }
                    }
                } catch (err) {
                    logDbg('❌ openConfirmationView inner error:', err?.message || err);
                }
            }, 250);

        }


        function closeConfirmationView() {
            const v = document.getElementById('confirmView');
            const phone = document.querySelector('.app-col');
            if (!v || !phone) return;
            stopConfirmPolling();                         // 👈 stop
            v.classList.remove('open');
            v.setAttribute('aria-hidden', 'true');
            phone.classList.remove('push-left');
            setTimeout(() => { v.style.display = 'none'; }, 280);
            document.getElementById('app').style.overflow = 'auto';
        }

        function hideBasketBar() {
            const bar = document.getElementById('basketFixed');
            if (!bar) return;
            bar.classList.remove('show');
            bar.style.display = 'none';                                // hard hide
            document.getElementById('app').style.scrollPaddingBottom = '0px';
        }

        function showBasketBar() {
            const bar = document.getElementById('basketFixed');
            if (!bar) return;
            bar.style.display = 'block';
            requestAnimationFrame(() => bar.classList.add('show'));
            document.getElementById('app').style.scrollPaddingBottom = '72px';
        }
        updateCheckoutCta();

        /* ===== Tracking polling ===== */
        let confirmPollTimer = null;
        function getActiveOrderId() {
            // your backend used to store this; fall back to querystring
            const local = localStorage.getItem('activeOrderId');
            if (local) return parseInt(local, 10);
            const qs = new URLSearchParams(location.search).get('orderId');
            return qs ? parseInt(qs, 10) : null;
        }

        function startConfirmPolling(orderId) {
            stopConfirmPolling();
            // initial render shell
            renderConfirmationShell(orderId);
            // first pull immediately
            fetchTracking(orderId).then(p => renderConfirmation(orderId, p)).catch(() => renderConfirmation(orderId, null));
            // then every 10s
            confirmPollTimer = setInterval(async () => {
                try {
                    const p = await fetchTracking(orderId);
                    renderConfirmation(orderId, p);
                } catch { /* ignore */ }
            }, 10000);
        }
        function stopConfirmPolling() {
            if (confirmPollTimer) { clearInterval(confirmPollTimer); confirmPollTimer = null; }
        }

        async function fetchTracking(orderId) {
            const ts = Date.now();
            const url = `/images/json/tracking/order-${orderId}.json?${ts}`;   // your server path
            const r = await fetch(url, { cache: 'no-store' });
            if (!r.ok) throw new Error('tracking http ' + r.status);
            return await r.json(); // shape: { status, eta, driver, location, ... }
        }

        /* ===== Confirmation rendering ===== */
        function renderConfirmationShell(orderId) {
            const body = document.getElementById('confirmBody');
            if (!body) return;
            body.innerHTML = `
    <div class="confirm-sections">
      <div id="confEta"    class="conf-eta"></div>
      <div id="confirmMap"></div>
      <div id="confDriver" class="conf-card" style="display:none"></div>
      <div id="confSummary" class="conf-card">
        <details class="conf-disclosure">
          <summary>Order summary</summary>
          <div id="confItems" style="margin-top:10px"></div>
          <div class="conf-row"><span style="color:#666">Items</span><span class="right" id="confItemsTotal">£0.00</span></div>
          <div class="conf-row" id="confDeliveryRow" style="display:none"><span style="color:#666">Delivery</span><span class="right" id="confDeliveryVal">£0.00</span></div>
          <hr style="border:none;border-top:1px solid #e5e5ea;margin:8px 0">
          <div class="conf-row"><strong>Total</strong><strong class="right" id="confGrand">£0.00</strong></div>
        </details>
      </div>
      <div id="confRewards" class="conf-card">
        <div class="conf-title">Rewards</div>
        <div id="confStamps" class="conf-row">You've earned <strong id="confStampCount">2</strong> stamps!</div>
      </div>
      <div id="confEmail" class="conf-card">
        <div class="conf-title">Send receipt to email</div>
        <div class="conf-row" style="gap:10px">
          <input id="confEmailInput" placeholder="you@example.com" style="flex:1;padding:10px;border:1px solid #ddd;border-radius:10px">
          <button id="confEmailBtn" class="conf-chip" type="button">Send</button>
        </div>
        <div id="confEmailMsg" style="font-size:13px;margin-top:6px;color:#1a7f37;display:none">Email sent</div>
      </div>
    </div>
  `;
            // email send hook
            document.getElementById('confEmailBtn').onclick = () => sendEmailReceipt(orderId);
        }

        function renderConfirmation(orderId, tracking) {
            // 1) Header ETA/status text
            const etaBox = document.getElementById('confEta');
            etaBox.innerHTML = `
    <div class="conf-row"><span class="conf-chip">#${String(orderId).slice(-3)}</span></div>
    <div class="conf-row" style="font-weight:800;font-size:22px" id="confEtaText">ETA updating…</div>
    <div class="conf-row" style="color:#666" id="confStatusText">Confirmed</div>
  `;

            // status + ETA text
            const statusText = prettyStatus(tracking?.status);
            const etaText = computeEtaText(tracking);
            document.getElementById('confStatusText').textContent = statusText;
            document.getElementById('confEtaText').textContent = etaText;

            // 2) Map + driver card
            const hasDriverLoc = tracking?.location && Number.isFinite(tracking.location.lat) && Number.isFinite(tracking.location.lng);
            if (hasDriverLoc) {
                renderConfirmMap(tracking.location);
            } else {
                const mapDiv = document.getElementById('confirmMap');
                if (mapDiv) mapDiv.innerHTML = ''; // collapse visually
            }
            renderDriverCard(tracking?.driver, tracking?.status);

            // 3) Order summary (best-effort from your persisted data)
            renderOrderSummary();

            // 4) Rewards stamps (same simple logic as before)
            const stamp = getStampCount();
            document.getElementById('confStampCount').textContent = String(stamp);
        }

        function prettyStatus(raw) {
            const s = (raw || '').toString().trim().toLowerCase();
            if (s === '4' || s === 'on_the_way' || s === 'in_transit' || s === 'enroute' || s === 'on the way') return 'On the way to you';
            if (s === '3' || s === 'preparing' || s === 'being_prepared') return 'Being prepared';
            if (s === '2' || s === 'driver_assigned' || s === 'assigned') return 'Driver assigned';
            if (s === '5' || s === 'delivered' || s === 'complete') return 'Delivered — enjoy!';
            if (s === '7' || s === 'canceled' || s === 'cancelled') return 'Order canceled';
            return 'Confirmed';
        }
        function computeEtaText(trk) {
            // 1) Try to extract minutes from multiple possible shapes
            const m = getEtaMinutes(trk);
            if (Number.isFinite(m) && m > 0) {
                if (m <= 60) return `Delivery in ${m} min`;
                const t = new Date(Date.now() + m * 60 * 1000);
                return humanArrivalString(t);
            }

            // 2) Fallback to a scheduled time the app saved
            const iso = localStorage.getItem('scheduledForISO') || '';
            if (iso) {
                const dt = new Date(iso);
                if (!isNaN(dt)) {
                    const mins = Math.max(0, Math.ceil((dt - Date.now()) / 60000));
                    if (mins <= 60) return `Delivery in ${mins} min`;
                    return humanArrivalString(dt);
                }
            }

            return 'ETA updating…';
        }

        function getEtaMinutes(trk) {
            if (!trk) return null;

            // numeric fields
            if (Number.isFinite(trk.etaMinutes)) return trk.etaMinutes;
            if (Number.isFinite(trk.arrivalMinutes)) return trk.arrivalMinutes;
            if (Number.isFinite(trk.etaMin)) return trk.etaMin;

            // nested objects (common: { eta: { minutes: 27 } } OR { eta: 27 })
            if (trk.eta) {
                if (Number.isFinite(trk.eta)) return trk.eta;
                if (Number.isFinite(trk.eta.minutes)) return trk.eta.minutes;
                if (typeof trk.eta.min === 'number') return trk.eta.min;
            }

            // strings like "27", "40-50", "45 mins"
            const str = String(trk.etaMinutes || trk.eta || '').trim();
            if (str) {
                const m = str.match(/\d+/);
                if (m) return parseInt(m[0], 10);
            }

            return null;
        }

        // London-friendly phrasing for times beyond 60 minutes
        function humanArrivalString(targetDate) {
            const t = targetDate;
            const hm = t.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
            const today = new Date();
            const isToday = t.toDateString() === today.toDateString();
            const isTomorrow = t.toDateString() === new Date(today.getTime() + 86400000).toDateString();

            if (isToday) return `Delivery today at ${hm}`;
            if (isTomorrow) return `Delivery tomorrow at ${hm}`;
            const d = t.toLocaleDateString('en-GB', { weekday: 'short', day: '2-digit', month: '2-digit' });
            return `Delivery at ${d} ${hm}`;
        }

        if (window._loggedOnce !== true) {
            console.log('[TRACKING payload]', tracking);
            window._loggedOnce = true;
        }

        /* ===== Map + driver ===== */
        function renderConfirmMap(driverLoc) {
            if (!window.google?.maps) return;
            const mapDiv = document.getElementById('confirmMap'); if (!mapDiv) return;
            const shop = getShopCoords();
            // customer destination (from saved address if present)
            const addr = JSON.parse(localStorage.getItem('savedAddressJSON') || 'null');
            const dest = (addr && Number.isFinite(addr.lat) && Number.isFinite(addr.lng)) ? { lat: addr.lat, lng: addr.lng } : null;

            // init map once
            if (!confirmMap) {
                confirmMap = new google.maps.Map(mapDiv, {
                    center: shop, zoom: 13, disableDefaultUI: true, clickableIcons: false
                });
                confirmMapShop = new google.maps.Marker({ position: shop, map: confirmMap, label: 'S' });
                if (dest) confirmMapDest = new google.maps.Marker({ position: dest, map: confirmMap, label: 'D' });
            }
            if (!confirmMapMarker) {
                confirmMapMarker = new google.maps.Marker({ position: driverLoc, map: confirmMap, label: '🚗' });
            } else {
                confirmMapMarker.setPosition(driverLoc);
            }

            // fit bounds to visible markers
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(shop);
            if (dest) bounds.extend(dest);
            bounds.extend(driverLoc);
            confirmMap.fitBounds(bounds, 40);
        }

        function renderDriverCard(driver, statusRaw) {
            const el = document.getElementById('confDriver'); if (!el) return;
            const show = driver && (String(statusRaw) !== 'delivered' && String(statusRaw) !== '5');
            if (!show) { el.style.display = 'none'; el.innerHTML = ''; return; }
            el.style.display = 'block';
            el.innerHTML = `
    <div class="conf-title">Your driver</div>
    <div class="conf-row"><span>Name</span><span class="right">${driver.name || '—'}</span></div>
    <div class="conf-row"><span>Phone</span><a class="right" href="tel:${(driver.phone || '').replace(/\s+/g, '')}">${driver.phone || '—'}</a></div>
  `;
        }

        /* ===== Summary (best effort) ===== */
        function renderOrderSummary() {
            // We don't have a normalized "saved order" object on web; use basket snapshot if you stored it,
            // else show totals composed from delivery info + (now empty) basket subtotal.
            let itemsHtml = '';
            let itemsTotal = 0;

            // if you persisted a snapshot before clearing (optional), you can read it here:
            // const snap = JSON.parse(localStorage.getItem('lastOrderSnapshot')||'null');

            // fallback: show only totals (you can enhance later to persist a snapshot)
            const subtotal = basketTotals().total; // likely 0 now because basket cleared before push
            const info = computeDeliveryInfo();
            const raw = info ? info.raw : 0;
            const fee = deliveryFee(raw, true);
            const grand = round2(subtotal + fee);

            document.getElementById('confItems').innerHTML = itemsHtml || `<div style="color:#666">Items will appear here.</div>`;
            document.getElementById('confItemsTotal').textContent = fmt.format(itemsTotal || subtotal);
            const drow = document.getElementById('confDeliveryRow');
            if (drow) {
                if (fee <= 0 && raw === 0) drow.style.display = 'none';
                else { drow.style.display = 'flex'; document.getElementById('confDeliveryVal').textContent = fee <= 0 ? 'FREE' : fmt.format(fee); }
            }
            document.getElementById('confGrand').textContent = fmt.format(grand);
        }

        /* ===== Rewards ===== */
        function getStampCount() {
            // mimic the Swift example: shared group storage may not exist on web; use localStorage
            const raw = parseInt(localStorage.getItem('stamps') || '2', 10);
            return Math.min(Math.max(raw || 2, 0), 10);
        }

        /* ===== Email receipt ===== */
        function sendEmailReceipt(orderId) {
            const input = document.getElementById('confEmailInput');
            const msg = document.getElementById('confEmailMsg');
            if (!input) return;
            const email = (input.value || '').trim();
            const ok = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(email);
            if (!ok) { msg.style.display = 'block'; msg.style.color = '#b00020'; msg.textContent = 'Please enter a valid email'; setTimeout(() => msg.style.display = 'none', 2000); return; }
            // Your brevo passthrough; adjust as needed:
            const url = `https://minitel.co.uk/utilities/emails/brevo.aspx?email=${encodeURIComponent(email)}&name=${encodeURIComponent('Customer')}&orderId=${encodeURIComponent(orderId || 0)}&shop=${encodeURIComponent(localStorage.getItem('shopId') || '1')}`;
            fetch(url).catch(() => { });
            input.value = ''; msg.style.display = 'block'; msg.style.color = '#1a7f37'; msg.textContent = 'Email sent'; setTimeout(() => msg.style.display = 'none', 2500);
        }


        function getDestCoords() {
            try {
                const a = JSON.parse(localStorage.getItem('savedAddressJSON') || 'null');
                if (a && Number.isFinite(a.lat) && Number.isFinite(a.lng)) return { lat: a.lat, lng: a.lng };
            } catch { }
            return null;
        }

        function waitForMaps(timeoutMs = 8000) {
            const start = Date.now();
            return new Promise((resolve, reject) => {
                (function check() {
                    if (window.google?.maps) return resolve();
                    if (Date.now() - start > timeoutMs) return reject(new Error('Maps not loaded'));
                    setTimeout(check, 80);
                })();
            });
        }

        /** Create/refresh base map with shop + dest; safe to call multiple times */
        async function initConfirmMapBase() {
            await waitForMaps().catch(() => { }); // don’t throw — we’ll just keep placeholder
            if (!window.google?.maps) return;

            const mapDiv = document.getElementById('confirmMap');
            if (!mapDiv) return;

            const shop = getShopCoords();
            const dest = getDestCoords(); // may be null if user hasn’t saved address

            if (!confirmMap) {
                confirmMap = new google.maps.Map(mapDiv, {
                    center: shop, zoom: 13, disableDefaultUI: true, clickableIcons: false
                });
            }

            // shop pin
            if (!confirmMapShop) {
                confirmMapShop = new google.maps.Marker({ position: shop, map: confirmMap, label: 'S' });
            } else {
                confirmMapShop.setPosition(shop);
            }

            // dest pin (optional)
            if (dest) {
                if (!confirmMapDest) confirmMapDest = new google.maps.Marker({ position: dest, map: confirmMap, label: 'D' });
                else confirmMapDest.setPosition(dest);
            } else if (confirmMapDest) {
                confirmMapDest.setMap(null); confirmMapDest = null;
            }

            // fit to what we have
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(shop);
            if (dest) bounds.extend(dest);
            confirmMap.fitBounds(bounds, 40);
        }

        /** Update/attach driver marker; call after initConfirmMapBase */
        function updateDriverOnConfirmMap(driverLoc) {
            if (!window.google?.maps || !confirmMap) return;
            if (!driverLoc) {
                if (confirmMapDriver) { confirmMapDriver.setMap(null); confirmMapDriver = null; }
                return;
            }
            if (!confirmMapDriver) {
                confirmMapDriver = new google.maps.Marker({ position: driverLoc, map: confirmMap, label: '🚗' });
            } else {
                confirmMapDriver.setPosition(driverLoc);
            }

            // Re-fit to include driver as well
            const shop = getShopCoords();
            const dest = getDestCoords();
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(shop);
            if (dest) bounds.extend(dest);
            bounds.extend(driverLoc);
            confirmMap.fitBounds(bounds, 40);
        }

        // --- basic fee: just return the raw fee
        function calcDeliveryFee(raw, subtotal, isDelivery) {
            return isDelivery ? round2(raw) : 0;
        }
        // ✅ alias for old callers
        function deliveryFee(raw, isDelivery = true) {
            return calcDeliveryFee(raw, 0, isDelivery);
        }

        const host = document.getElementById('stickyBarHost');
        const syncCatbarH = () => {
            document.documentElement.style.setProperty('--catbar-h', `${host?.offsetHeight || 56}px`);
        };
        new ResizeObserver(syncCatbarH).observe(host);
        window.addEventListener('resize', syncCatbarH, { passive: true });
        syncCatbarH();

        // === CONFIG ===
        // Build a clean payload from current state
        async function buildOrderPayload() {
            const addr = JSON.parse(localStorage.getItem('savedAddressJSON') || 'null') || {};
            const scheduledForISO = localStorage.getItem('scheduledForISO') || '';

            // 🔑 only one field now
            //  const stripePaymentIntentId = await ensurePaymentReference();
            const stripePaymentIntentId = "1234";

            const items = basket.map(row => ({
                id: row.id,
                name: row.name,
                qty: row.qty,
                unitPrice: row.unitPrice,
                option: row.option ? { name: row.option.name, price: row.option.price || 0 } : null,
                additions: (row.additions || []).map(a => ({ name: a.name, price: a.price || 0 })),
                image: row.image || ''
            }));

            const subtotal = basketTotals().total;
            const delInfo = computeDeliveryInfo();
            const deliveryFeeVal = delInfo ? round2(delInfo.fee) : 0;
            const grand = round2(subtotal + deliveryFeeVal);

            return {
                currency: 'GBP',
                subtotal,
                deliveryFee: deliveryFeeVal,
                total: grand,
                scheduledForISO: scheduledForISO || null,
                items,

                customer: {
                    name: localStorage.getItem('userName') || '',
                    email: localStorage.getItem('userEmail') || '',
                    phoneE164: localStorage.getItem('userPhone') || '',
                },

                address: {
                    streetName: addr.streetName || '',
                    streetNumber: addr.streetNumber || '',
                    postcode: (addr.postcode || '').toUpperCase(),
                    instructions: addr.instructions || '',
                    lat: addr.lat ?? null,
                    lng: addr.lng ?? null,
                },

                // keep for reconciliation if your server still checks it
                paymentMethodId: localStorage.getItem('savedPaymentMethodId') || null,

                // ✅ only this field is required by your backend now
                stripePaymentIntentId,

                meta: {
                    shopId: localStorage.getItem('shopId') || '1',
                    source: 'pwa'
                }
            };
        }

        // Optional: persist last completed order snapshot (for your confirmation summary, etc.)
        function persistLastCompletedOrder(orderId, orderPayload) {
            try {
                localStorage.setItem('lastOrderId', String(orderId));
                localStorage.setItem('activeOrderId', String(orderId)); // used by getActiveOrderId()
                localStorage.setItem('lastOrderSnapshot', JSON.stringify({
                    id: orderId,
                    createdAt: new Date().toISOString(),
                    payload: orderPayload
                }));
            } catch { }
        }

        // Optional: stamps logic like your SwiftUI version
        function bumpStamps() {
            const key = 'stamps';
            let stamps = parseInt(localStorage.getItem(key) || 'NaN', 10);
            if (!Number.isFinite(stamps)) stamps = 2;          // start at 2 if missing
            else if (stamps < 10) stamps = stamps + 1;         // cap at 10
            localStorage.setItem(key, String(stamps));
        }

        // A tiny UI guard
        function setCheckoutBusy(isBusy) {
            const btn = document.getElementById('bsCheckout');
            if (!btn) return;
            btn.disabled = isBusy;
            btn.textContent = isBusy ? 'PROCESSING…' : 'CONFIRM ORDER';
        }

        // Submit flow used by the CTA
        async function submitOrder() {
            try {
                if (basket.length === 0) { alert('Your basket is empty.'); return; }
                if (!hasSavedAddress()) { openAddrFullScreen(); return; }
                if (!hasSavedCard()) { openCardModal(); return; }

                setCheckoutBusy(true);

                const payload = await buildOrderPayload();  // ⬅️ now includes stripePaymentIntentId only

                const resp = await fetch(SUBMIT_ORDER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const json = await resp.json().catch(() => ({}));
                if (!resp.ok) throw new Error(json?.message || `Server error (${resp.status})`);

                const orderId = Number(json?.orderId);
                if (!Number.isFinite(orderId) || orderId <= 0) {
                    throw new Error(json?.message || 'Unexpected server response.');
                }

                persistLastCompletedOrder(orderId, payload);
                bumpStamps();

                basket = []; saveBasket(); updateBasketBar();
                openConfirmationView();

            } catch (err) {
                alert(err.message || String(err));
            } finally {
                setCheckoutBusy(false);
            }
        }

        // Always create a Stripe PaymentIntent using the saved card (PaymentMethodId)
        async function ensurePaymentReference() {
            const pmId = localStorage.getItem('savedPaymentMethodId');
            if (!pmId) {
                throw new Error('No saved card. Please add a card first.');
            }

            const { grand } = computeGrand();
            const amount = Math.round(grand * 100); // in pence
            if (!Number.isFinite(amount) || amount <= 0) {
                throw new Error('Invalid order total.');
            }

            // Ask your backend to create a PaymentIntent
            const resp = await fetch('/create-payment-intent', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    amount,
                    currency: 'gbp',
                    paymentMethod: pmId,
                    confirm: false,                     // let backend confirm when order is accepted
                    description: 'Web card order',
                    metadata: { source: 'pwa' }
                })
            });

            const json = await resp.json().catch(() => ({}));
            if (!resp.ok) {
                throw new Error(json?.error || 'Unable to create PaymentIntent.');
            }

            const stripePaymentIntentId = json.id || json.payment_intent?.id;
            if (!stripePaymentIntentId) {
                throw new Error('PaymentIntent id missing from server response.');
            }

            // optional debug
            localStorage.setItem('lastPI', stripePaymentIntentId);

            return stripePaymentIntentId;
        }
    </script>
</body>
</html>